<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圖片文字修改專家 - v20.0 新增PPTX匯出功能</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- 新增 PPTX 生成庫 -->
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <script>
        // 設定 PDF.js Worker
        window.onload = function() {
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            initDB(); 
        };
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Noto+Serif+TC:wght@400;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; user-select: none; }
        
        canvas { 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); 
            transform-origin: 0 0; 
        }
        .pattern-grid {
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .tool-btn.active { background-color: #2563eb; color: white; border-color: #2563eb; }
        .slide-thumb { border: 2px solid transparent; transition: all 0.2s; cursor: pointer; opacity: 0.7; }
        .slide-thumb:hover { opacity: 1; }
        .slide-thumb.active { border-color: #2563eb; opacity: 1; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2); }

        #toast {
            visibility: hidden; min-width: 250px; background-color: #333; color: #fff; text-align: center;
            border-radius: 8px; padding: 12px 16px; position: fixed; z-index: 100; left: 50%; top: -60px; 
            transform: translateX(-50%); font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0; transition: opacity 0.3s, top 0.3s;
        }
        #toast.show { visibility: visible; opacity: 1; top: 20px; }
        #toast.error { background-color: #ef4444; }

        .cursor-crosshair { cursor: crosshair; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-magic { cursor: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM5MzMzZWEiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMTQuNSAyYTMuNSAzLjUgMCAwIDEgNSA1bC0yLjUgMi41TDguNSAyMGwtNC41IDFsMS00LjVMMTQuNSAyeiIvPjxwYXRoIGQ9Ik0yMSAxMmwyIDItMiAyTTMgMTJsLTIgMiAyIDIiLz48L3N2Zz4=") 0 24, crosshair !important; }
        .cursor-dropper { cursor: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTE0LjUgMmEzLjUgMy41IDAgMCAxIDUgNWwtMi41IDIuNUw4LjUgMjBsLTQuNSAxbDEtNC41TDE0LjUgMnoiLz48bGluZSB4MT0iMyIgeTE9IjIxIiB4Mj0iOSIgeTI9IjE1Ii8+PC9zdmc+") 0 24, crosshair !important; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- 載入遮罩 -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden flex flex-col items-center justify-center text-white">
        <div class="loader mb-4"></div>
        <h2 class="text-xl font-bold mb-2">處理中...</h2>
        <p id="loadingStatus" class="text-sm text-gray-200 font-mono">初始化...</p>
    </div>

    <!-- 恢復進度對話框 -->
    <div id="restoreModal" class="fixed inset-0 bg-black bg-opacity-60 z-50 hidden flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 w-96 text-center transform transition-all scale-100">
            <div class="mb-4 text-blue-600 text-4xl"><i class="fas fa-history"></i></div>
            <h3 class="text-lg font-bold text-gray-800 mb-2">發現未完成的編輯</h3>
            <p class="text-sm text-gray-600 mb-6">系統偵測到您上次有未儲存的進度。是否要還原上次的編輯內容？</p>
            <div class="flex gap-3 justify-center">
                <button onclick="discardSession()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded transition">捨棄</button>
                <button onclick="restoreSession()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition">還原資料</button>
            </div>
        </div>
    </div>

    <div id="toast"><i class="fas fa-save mr-2 text-green-400"></i>已自動暫存編輯進度</div>

    <!-- 頂部導覽列 -->
    <header class="bg-white border-b border-gray-200 p-3 flex justify-between items-center z-10 shadow-sm shrink-0">
        <div class="flex items-center gap-2">
            <div class="bg-blue-600 text-white p-2 rounded-lg"><i class="fas fa-file-pdf"></i></div>
            <div class="flex flex-col">
                <h1 class="text-lg font-bold text-gray-800 leading-tight">圖片文字修改專家 <span class="text-xs bg-red-600 text-white px-2 py-0.5 rounded font-mono ml-1">v20.0</span></h1>
                <span class="text-[10px] text-gray-500">NotebookLM 簡報專用編輯器</span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="undo()" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-lg transition" title="復原 (Ctrl+Z)"><i class="fas fa-undo"></i></button>
            <button onclick="redo()" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-lg transition" title="重做 (Ctrl+Y)"><i class="fas fa-redo"></i></button>
            <div class="w-px h-8 bg-gray-300 mx-1"></div>
            <button onclick="document.getElementById('fileInput').click()" class="bg-indigo-50 hover:bg-indigo-100 text-indigo-700 px-4 py-2 rounded-lg transition flex items-center gap-2 border border-indigo-200"><i class="fas fa-file-upload"></i> <span class="hidden sm:inline">匯入</span></button>
            <div class="flex rounded-lg shadow-sm" role="group">
                <button onclick="downloadImage()" class="bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 px-4 py-2 rounded-l-lg text-sm font-medium"><i class="fas fa-image"></i> 單頁</button>
                <button onclick="downloadPPTX()" class="bg-white border-t border-b border-gray-300 hover:bg-gray-50 text-orange-600 px-4 py-2 text-sm font-medium"><i class="fas fa-file-powerpoint"></i> PPTX</button>
                <button onclick="downloadPDF()" class="bg-blue-600 border border-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-r-lg text-sm font-medium"><i class="fas fa-file-pdf"></i> PDF</button>
            </div>
            <input type="file" id="fileInput" accept="image/*,application/pdf" class="hidden">
            <input type="file" id="overlayInput" accept="image/*" class="hidden">
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        <!-- 左側縮圖欄 -->
        <div id="slidesPanel" class="w-48 bg-gray-50 border-r border-gray-200 flex flex-col shrink-0 hidden">
            <div class="p-3 border-b border-gray-200 bg-gray-100"><h3 class="text-xs font-bold text-gray-500 uppercase">投影片 (<span id="slideCount">0</span>)</h3></div>
            <div id="slidesContainer" class="flex-1 overflow-y-auto p-3 space-y-3 custom-scroll"></div>
        </div>

        <!-- 左側工具欄 -->
        <aside class="w-72 bg-white border-r border-gray-200 flex flex-col p-3 gap-3 overflow-y-auto z-10 shadow-lg shrink-0 custom-scroll">
            <div class="bg-gray-50 p-2 rounded-lg border border-gray-200 grid grid-cols-6 gap-1">
                <button onclick="setTool('select')" id="toolSelect" class="tool-btn active p-2 rounded hover:bg-white transition col-span-1" title="選取"><i class="fas fa-mouse-pointer"></i></button>
                <button onclick="setTool('hand')" id="toolHand" class="tool-btn p-2 rounded hover:bg-white transition col-span-1" title="平移"><i class="fas fa-hand-paper"></i></button>
                <button onclick="setTool('rect')" id="toolRect" class="tool-btn p-2 rounded hover:bg-white transition col-span-1" title="色塊"><i class="fas fa-vector-square"></i></button>
                <button onclick="adjustZoom(-0.1)" class="p-2 rounded bg-white hover:bg-gray-100 transition col-span-1"><i class="fas fa-minus"></i></button>
                <button onclick="adjustZoom(0.1)" class="p-2 rounded bg-white hover:bg-gray-100 transition col-span-1"><i class="fas fa-plus"></i></button>
                <button onclick="resetView()" class="p-2 rounded bg-white hover:bg-gray-100 transition col-span-1"><i class="fas fa-expand"></i></button>
                <div class="col-span-6 text-center text-[10px] text-gray-400 mt-1" id="zoomLevel">100%</div>
            </div>

            <!-- 塗抹去印工具 -->
            <div class="bg-rose-50 p-3 rounded-lg border border-rose-200 space-y-2" id="maskToolSection">
                 <h3 class="text-xs font-bold text-rose-700 uppercase tracking-wider mb-1 flex justify-between items-center">
                     <span><i class="fas fa-magic"></i> 塗抹去印</span>
                     <button onclick="exitMaskMode()" id="exitMaskBtn" class="hidden text-[10px] bg-white border border-rose-300 text-rose-600 px-2 py-0.5 rounded hover:bg-rose-100">退出模式</button>
                 </h3>
                 
                 <div id="maskEnterPanel">
                     <p class="text-[10px] text-rose-600 leading-tight mb-2">適合去除浮水印或小瑕疵。</p>
                     <button onclick="setTool('mask')" class="w-full tool-btn bg-white border border-rose-200 hover:bg-rose-100 text-rose-900 py-1.5 rounded shadow-sm text-sm font-bold flex items-center justify-center gap-2">
                         <i class="fas fa-paint-brush"></i> 開始塗抹
                     </button>
                 </div>

                 <div id="maskOptions" class="hidden text-xs text-rose-800 space-y-2 pt-2 border-t border-rose-200">
                     <div class="flex items-center justify-between"><span>筆刷: <span id="brushSizeVal">60</span></span><input type="range" id="brushSize" min="5" max="100" value="60" class="w-16 h-2 bg-rose-200 rounded-lg cursor-pointer"></div>
                     <div class="flex gap-2 pt-1">
                         <button onclick="clearMask()" class="flex-1 bg-white hover:bg-gray-100 text-gray-600 py-1 rounded border border-gray-300">清除筆跡</button>
                         <button id="applyMaskBtn" onclick="applyMaskRemoval()" disabled class="flex-1 bg-rose-600 hover:bg-rose-700 text-white py-1 rounded shadow disabled:opacity-50 font-bold">去除水印</button>
                     </div>
                 </div>
            </div>

            <!-- 主要操作按鈕 -->
            <div id="controls" class="space-y-3 opacity-50 pointer-events-none transition-opacity duration-300 pb-8">
                <div class="space-y-1">
                    <label class="block text-xs font-bold text-gray-500 uppercase tracking-wider">選取操作</label>
                    <div class="grid grid-cols-2 gap-2">
                        <!-- OCR 放置首位 -->
                        <button id="ocrBtn" onclick="runOCR()" disabled class="col-span-1 bg-indigo-600 hover:bg-indigo-700 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]"><i class="fas fa-font"></i> <span>文字辨識</span></button>
                        <button id="magicBtn" onclick="magicCrop()" disabled class="col-span-1 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]"><i class="fas fa-cut"></i> <span>截圖去背</span></button>
                        <button id="watermarkBtn" onclick="removeWatermarkSelection()" disabled class="col-span-1 bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-600 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]"><i class="fas fa-magic"></i> <span>選框去印</span></button>
                        <button id="eraseBtn" onclick="eraseSelection()" disabled class="col-span-1 bg-gray-500 hover:bg-gray-600 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]"><i class="fas fa-eraser"></i> <span>純色覆蓋</span></button>
                    </div>
                </div>
                
                <div class="flex flex-col gap-2 border-t pt-3">
                    <div class="flex gap-2">
                         <button onclick="addText()" class="flex-1 bg-white border border-gray-300 hover:border-indigo-500 text-gray-600 py-1.5 rounded-lg font-bold text-xs"><i class="fas fa-font"></i> 文字</button>
                         <button onclick="addQRCode()" class="flex-1 bg-white border border-gray-300 hover:border-green-500 text-gray-600 py-1.5 rounded-lg font-bold text-xs"><i class="fas fa-qrcode"></i> QR</button>
                    </div>
                    <button onclick="document.getElementById('overlayInput').click()" class="w-full bg-white border border-gray-300 hover:border-orange-500 text-gray-600 py-1.5 rounded-lg font-bold text-xs"><i class="fas fa-image"></i> 圖片/Logo</button>
                </div>

                <!-- 屬性面板 -->
                <div class="border-t pt-3">
                    <div class="flex justify-between items-center mb-2"><h3 class="text-xs font-bold text-gray-500 uppercase">屬性</h3><button onclick="deleteSelected()" class="text-red-500 hover:bg-red-50 px-2 py-1 rounded text-xs"><i class="fas fa-trash"></i></button></div>
                    
                    <!-- 文字屬性 -->
                    <div id="textProperties" class="space-y-2 hidden">
                        <textarea id="textInput" rows="2" class="w-full border border-gray-300 rounded p-1.5 text-xs"></textarea>
                        <div class="grid grid-cols-2 gap-2">
                            <div><label class="text-[10px] text-gray-500">大小</label><input type="number" id="fontSize" class="w-full border rounded p-1 text-xs"></div>
                            <div><label class="text-[10px] text-gray-500">顏色</label><div class="flex items-center gap-1 border rounded p-1 bg-white"><input type="color" id="textColor" class="w-4 h-4"><span id="textColorHex" class="text-[10px] text-gray-400"></span></div></div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                             <div><label class="text-[10px] text-gray-500">字距 (px)</label><input type="number" id="letterSpacing" class="w-full border rounded p-1 text-xs" step="1" value="0"></div>
                             <div><label class="text-[10px] text-gray-500">行距</label><input type="number" id="lineHeight" class="w-full border rounded p-1 text-xs" step="0.1" value="1.2"></div>
                        </div>
                        <div><label class="text-[10px] text-gray-500">背景</label><div class="flex items-center gap-1 border rounded p-1 bg-white"><input type="checkbox" id="hasBackground" class="accent-blue-600 mr-1"><input type="color" id="bgColor" class="w-4 h-4"><button onclick="activateEyedropper()" id="eyedropperBtn" class="ml-auto text-xs p-1 hover:bg-gray-100 rounded text-gray-500"><i class="fas fa-eye-dropper"></i></button></div></div>
                        <div><label class="text-[10px] text-gray-500">字重</label><select id="fontWeight" class="w-full border rounded p-1 text-xs"><option value="normal">一般</option><option value="bold">粗體</option></select></div>
                    </div>
                    
                    <!-- 圖片屬性 -->
                    <div id="imageProperties" class="space-y-2 hidden">
                         <div class="bg-purple-50 p-2 rounded border border-purple-100 mb-2">
                             <button onclick="startPickRemoveBg()" id="pickRemoveBgBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white py-1.5 rounded text-xs mb-1 font-bold"><i class="fas fa-eye-dropper"></i> 吸色去背</button>
                             <p class="text-[10px] text-purple-600 leading-tight">點擊按鈕後，再點選圖片中的背景顏色即可去除。</p>
                         </div>
                         <div><label class="text-[10px] text-gray-500">容許值: <span id="bgToleranceVal">50</span></label><input type="range" id="bgTolerance" min="1" max="150" value="50" class="w-full h-1 bg-gray-200 rounded-lg cursor-pointer"></div>
                         <div><label class="text-[10px] text-gray-500">縮放</label><input type="range" id="imgScale" min="0.1" max="5" step="0.1" class="w-full h-1 bg-gray-200 rounded-lg cursor-pointer"></div>
                    </div>

                    <!-- 色塊屬性 -->
                    <div id="blockProperties" class="space-y-2 hidden">
                        <div><label class="text-[10px] text-gray-500">顏色</label><div class="flex items-center gap-1 border border-gray-300 rounded p-1 bg-white"><input type="color" id="blockColor" class="w-4 h-4 border border-gray-200"><button onclick="activateEyedropper()" id="eyedropperBlockBtn" class="ml-auto text-xs p-1 hover:bg-gray-100 rounded text-gray-500"><i class="fas fa-eye-dropper"></i></button></div></div>
                   </div>
                </div>
            </div>
        </aside>

        <!-- 主畫布區域 -->
        <main class="flex-1 bg-gray-200 pattern-grid relative overflow-hidden" id="canvasContainer">
            <div id="placeholder" class="flex flex-col h-full justify-center items-center text-center text-gray-400 pointer-events-none select-none p-8">
                <i class="fas fa-file-pdf text-6xl mb-4 text-gray-300"></i>
                <h2 class="text-xl font-bold text-gray-500">載入簡報開始編輯</h2>
                <p class="text-sm mt-2 text-gray-400 max-w-md">支援 NotebookLM 生成的 PDF 簡報或一般圖片。載入後可逐頁去浮水印、修補背景或加入註解。</p>
            </div>
            <canvas id="canvas" class="hidden shadow-2xl bg-white absolute top-0 left-0 origin-top-left"></canvas>
            <div id="qrCodeTemp" class="hidden"></div>
        </main>
    </div>

    <script>
        // --- 1. Global Utilities (Moved to Top) ---
        function showToast(msg, isError = false) {
            const t = document.getElementById('toast');
            if(!t) return;
            t.innerHTML = isError ? `<i class="fas fa-exclamation-triangle mr-2"></i> ${msg}` : `<i class="fas fa-check-circle mr-2 text-green-400"></i> ${msg}`;
            t.className = isError ? "show error" : "show";
            setTimeout(() => { t.className = ""; }, 3000);
        }

        // --- Global State ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const overlayInput = document.getElementById('overlayInput');
        const controls = document.getElementById('controls');
        const placeholder = document.getElementById('placeholder');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingStatus = document.getElementById('loadingStatus');
        const canvasContainer = document.getElementById('canvasContainer');
        const slidesContainer = document.getElementById('slidesContainer');
        const slideCountDisplay = document.getElementById('slideCount');
        const restoreModal = document.getElementById('restoreModal');
        
        let currentSlideIndex = 0, slides = [], img = new Image(); 
        let texts = [], patches = [], blocks = [], images = [], maskStrokes = [];
        let selectedIndex = -1, selectedType = null; 
        let view = { scale: 1, x: 0, y: 0 };
        let currentTool = 'select';
        let isSelecting = false, selectionBox = { x: 0, y: 0, w: 0, h: 0, active: false };
        let selectionStartX = 0, selectionStartY = 0; 
        // 修正：補回遺失的全域變數
        let isCreatingRect = false, newRectStart = { x: 0, y: 0 };
        let isDraggingView = false, lastMouseX = 0, lastMouseY = 0;
        let isDraggingItem = false, isResizingItem = false, dragOffset = { x: 0, y: 0 }, resizeStart = { w:0, h:0, x:0, y:0, fontSize:0 }; 
        let isDraggingSelection = false, isDrawingMask = false;
        let historyStack = [], historyPointer = -1; const MAX_HISTORY = 20;
        let db; const DB_NAME='ImgEditorDB', DB_VERSION=1, STORE_NAME='sessions';

        // --- Classes ---
        class TextBlock {
            constructor(x, y, text, fontSize = 30, w = 0, h = 0) {
                this.x = Math.floor(x || 0); this.y = Math.floor(y || 0); 
                this.text = text; this.fontSize = fontSize;
                this.fontFamily = "'Noto Sans TC', sans-serif"; this.fontWeight = 'bold';
                this.color = '#000000'; this.hasBackground = false; this.bgColor = '#ffffff';
                this.padding = 8; this.textAlign = 'left'; this.lineHeight = 1.2;
                this.letterSpacing = 0; 
                this.width = Math.max(20, Math.floor(w || 100)); 
                this.height = Math.max(20, Math.floor(h || 50)); 
            }
        }
        // Updated PatchBlock to support texture image
        class PatchBlock { 
            constructor(x, y, w, h, color, src) { 
                this.x=x; this.y=y; this.w=w; this.h=h; this.color=color; this.src=src; this.imgElement=null;
            }
            load(cb) {
                if(this.src) {
                    this.imgElement = new Image();
                    this.imgElement.onload = cb;
                    this.imgElement.onerror = cb;
                    this.imgElement.src = this.src;
                } else {
                    if(cb) cb();
                }
            }
        }
        class ColorBlock { constructor(x, y, w, h, color) { this.x=x; this.y=y; this.width=w; this.height=h; this.color=color; } }
        class ImageBlock {
            constructor(x, y, imgSrc, w, h) { this.x=x; this.y=y; this.src=imgSrc; this.imgElement=null; this.scale=1; this.width=w; this.height=h; }
            load(cb) {
                this.imgElement = new Image();
                this.imgElement.onload = () => {
                    if(!this.width) this.width = this.imgElement.width;
                    if(!this.height) this.height = this.imgElement.height;
                    if(cb) cb();
                }
                this.imgElement.onerror = () => { if(cb) cb(); }; 
                this.imgElement.src = this.src;
            }
        }

        // --- Persistence (DB) ---
        function initDB() { if(!window.indexedDB)return; const r=indexedDB.open(DB_NAME, DB_VERSION); r.onupgradeneeded=(e)=>{db=e.target.result; if(!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);}; r.onsuccess=(e)=>{db=e.target.result; checkSession();}; }
        function checkSession() { if(!db)return; const tx=db.transaction(STORE_NAME,'readonly'); const req=tx.objectStore(STORE_NAME).get('latest'); req.onsuccess=()=>{ if(req.result && req.result.slides?.length>0) restoreModal.classList.remove('hidden'); }; }
        let saveT; function debouncedSaveSession() { clearTimeout(saveT); saveT=setTimeout(saveSessionToDB, 1000); }
        function saveSessionToDB() { if(!db||slides.length===0)return; saveSlideState(); const sData=slides.map(s=>({ imgSrc:s.originalImage.src, thumbnail:s.thumbnail, texts:s.texts, patches:s.patches, blocks:s.blocks, images:s.images, maskStrokes:s.maskStrokes })); db.transaction(STORE_NAME,'readwrite').objectStore(STORE_NAME).put({id:'latest', slides:sData, timestamp:Date.now()}, 'latest'); showToast("已自動備份"); }
        function restoreSession() { restoreModal.classList.add('hidden'); loadingOverlay.classList.remove('hidden'); loadingStatus.textContent="還原中..."; db.transaction(STORE_NAME,'readonly').objectStore(STORE_NAME).get('latest').onsuccess=async(e)=>{ const d=e.target.result; if(!d){loadingOverlay.classList.add('hidden');return;} slides=[]; for(const s of d.slides){ const i=new Image(); i.src=s.imgSrc; await new Promise(r=>i.onload=r); slides.push({originalImage:i, thumbnail:s.thumbnail, texts:s.texts||[], patches:s.patches||[], blocks:s.blocks||[], images:s.images||[], maskStrokes:s.maskStrokes||[]}); } controls.classList.remove('opacity-50','pointer-events-none'); placeholder.classList.add('hidden'); canvas.classList.remove('hidden'); renderSlideThumbnails(); loadSlide(0, false); loadingOverlay.classList.add('hidden'); showToast("還原成功"); }; }
        function discardSession() { restoreModal.classList.add('hidden'); if(db) db.transaction(STORE_NAME,'readwrite').objectStore(STORE_NAME).delete('latest'); }

        // --- Core History ---
        function recordHistory() { if(historyPointer<historyStack.length-1) historyStack=historyStack.slice(0, historyPointer+1); historyStack.push(JSON.stringify({texts,patches,blocks,images:images.map(i=>({x:i.x,y:i.y,src:i.src,scale:i.scale,width:i.width,height:i.height})),maskStrokes})); if(historyStack.length>MAX_HISTORY) historyStack.shift(); else historyPointer++; saveSlideState(); debouncedSaveSession(); }
        function undo() { if(historyPointer>0) { historyPointer--; loadHistoryState(historyStack[historyPointer]); showToast("已復原"); } }
        function redo() { if(historyPointer<historyStack.length-1) { historyPointer++; loadHistoryState(historyStack[historyPointer]); showToast("已重做"); } }
        function loadHistoryState(jsonStr) {
            if(!jsonStr) return;
            const state = JSON.parse(jsonStr);
            texts = state.texts.map(t => Object.assign(new TextBlock(), t));
            const savedPatches = state.patches || [];
            patches = [];
            const savedImgs = state.images || [];
            images = []; 
            blocks = state.blocks.map(b => Object.assign(new ColorBlock(), b));
            maskStrokes = state.maskStrokes || [];
            let pending = savedImgs.length + savedPatches.length;
            const checkDone = () => { if(pending <= 0) draw(); };
            savedPatches.forEach(pd => { const pb = new PatchBlock(pd.x, pd.y, pd.w, pd.h, pd.color, pd.src); pb.load(() => { pending--; checkDone(); }); patches.push(pb); });
            savedImgs.forEach(idata => { const ib = new ImageBlock(idata.x, idata.y, idata.src, idata.width, idata.height); ib.scale = idata.scale; ib.load(() => { pending--; checkDone(); }); images.push(ib); });
            if(pending === 0) draw();
            deselectAll(); saveSlideState(); debouncedSaveSession();
        }

        // --- Slide Management ---
        function saveSlideState() { if(slides[currentSlideIndex]) { Object.assign(slides[currentSlideIndex], {texts:JSON.parse(JSON.stringify(texts)), patches:JSON.parse(JSON.stringify(patches)), blocks:JSON.parse(JSON.stringify(blocks)), images:images.map(i=>({x:i.x,y:i.y,src:i.src,scale:i.scale,width:i.width,height:i.height})), maskStrokes:JSON.parse(JSON.stringify(maskStrokes))}); } }
        
        function loadSlide(i, saveCurrent = true) { 
            if(i<0||i>=slides.length)return; 
            if(slides.length>0 && saveCurrent) saveSlideState(); 
            currentSlideIndex=i; 
            document.querySelectorAll('.slide-thumb').forEach((el,idx)=>{el.classList.toggle('active',idx===i); if(idx===i)el.scrollIntoView({behavior:'smooth',block:'nearest'});}); 
            const s=slides[i]; 
            img=s.originalImage; 
            texts=(s.texts||[]).map(t=>Object.assign(new TextBlock(),t)); 
            const savedPatches = s.patches || [];
            patches = [];
            savedPatches.forEach(pd => { const pb = new PatchBlock(pd.x, pd.y, pd.w, pd.h, pd.color, pd.src); pb.load(draw); patches.push(pb); });
            blocks=(s.blocks||[]).map(b=>Object.assign(new ColorBlock(),b)); 
            maskStrokes=s.maskStrokes||[]; 
            const savedImgs=s.images||[]; 
            images=[]; 
            savedImgs.forEach(d=>{ const b=new ImageBlock(d.x,d.y,d.src,d.width,d.height); b.scale=d.scale; b.load(draw); images.push(b); }); 
            historyStack=[]; historyPointer=-1; recordHistory(); resetView(); draw();
        }

        // --- File I/O ---
        fileInput.onchange=async(e)=>{ if(e.target.files[0]){ loadingOverlay.classList.remove('hidden'); loadingStatus.textContent="讀取中..."; if(db)db.transaction(STORE_NAME,'readwrite').objectStore(STORE_NAME).delete('latest'); if(e.target.files[0].type==='application/pdf'){ if(typeof pdfjsLib!=='undefined') await handlePDF(e.target.files[0]); else {alert("PDF 未載入");loadingOverlay.classList.add('hidden');} } else await handleImage(e.target.files[0]); loadingOverlay.classList.add('hidden'); controls.classList.remove('opacity-50','pointer-events-none'); placeholder.classList.add('hidden'); canvas.classList.remove('hidden'); } e.target.value=''; };
        overlayInput.onchange=(e)=>{ if(e.target.files[0]&&img.src){ const r=new FileReader(); r.onload=(ev)=>{ const i=new Image(); i.onload=()=>{ const s=Math.min(1,(canvas.width*0.5)/i.width); const b=new ImageBlock((canvas.width-i.width*s)/2,(canvas.height-i.height*s)/2,i.src,i.width,i.height); b.scale=s; b.load(()=>{images.push(b); recordHistory(); draw(); selectItem('image',images.length-1);}); }; i.src=ev.target.result; }; r.readAsDataURL(e.target.files[0]); } e.target.value=''; };
        async function handleImage(f){ return new Promise(resolve=>{ const r=new FileReader(); r.onload=(e)=>{ const i=new Image(); i.onload=()=>{ slides=[{originalImage:i,thumbnail:i.src,texts:[],patches:[],blocks:[],images:[],maskStrokes:[]}]; renderSlideThumbnails(); loadSlide(0, false); resolve(); }; i.src=e.target.result; }; r.readAsDataURL(f); }); }
        async function handlePDF(f){ try { const d=await f.arrayBuffer(); const pdf=await pdfjsLib.getDocument({data:d}).promise; slides=[]; for(let i=1;i<=pdf.numPages;i++){ loadingStatus.textContent=`處理頁面 ${i}/${pdf.numPages}...`; const p=await pdf.getPage(i); const v=p.getViewport({scale:2.0}); const c=document.createElement('canvas'); c.width=v.width; c.height=v.height; await p.render({canvasContext:c.getContext('2d'),viewport:v}).promise; const s=c.toDataURL('image/jpeg',0.85); const io=new Image(); io.src=s; await new Promise(r=>io.onload=r); slides.push({originalImage:io,thumbnail:s,texts:[],patches:[],blocks:[],images:[],maskStrokes:[]}); } renderSlideThumbnails(); loadSlide(0, false); } catch(e){console.error(e);alert("PDF 錯誤");} }
        function renderSlideThumbnails(){ slidesContainer.innerHTML=''; slides.forEach((s,i)=>{ const d=document.createElement('div'); d.className=`slide-thumb relative rounded overflow-hidden shadow-sm bg-white aspect-[4/3] flex items-center justify-center ${i===currentSlideIndex?'active':''}`; d.onclick=()=>loadSlide(i); const tm=document.createElement('img'); tm.src=s.thumbnail; tm.className="max-w-full max-h-full object-contain"; d.innerHTML=`<div class="absolute bottom-1 right-1 bg-black bg-opacity-50 text-white text-[10px] px-1.5 rounded">${i+1}</div>`; d.prepend(tm); slidesContainer.appendChild(d); }); slideCountDisplay.textContent=slides.length; document.getElementById('slidesPanel').classList.remove('hidden'); }

        // --- Core Algorithms ---
        function getDominantBorderColor(x, y, w, h) {
            try {
                const safeX = Math.max(0, x), safeY = Math.max(0, y), safeW = Math.min(img.width-safeX, w), safeH = Math.min(img.height-safeY, h);
                if(safeW<=0||safeH<=0) return '#ffffff';
                const tempC = document.createElement('canvas'); tempC.width=safeW; tempC.height=safeH; const tx=tempC.getContext('2d');
                tx.drawImage(img,safeX,safeY,safeW,safeH,0,0,safeW,safeH);
                const points = [], sw=Math.floor(safeW), sh=Math.floor(safeH);
                for(let i=0;i<sw;i+=5){points.push({x:i,y:0});points.push({x:i,y:sh-1});} for(let j=0;j<sh;j+=5){points.push({x:0,y:j});points.push({x:sw-1,y:j});}
                if(points.length===0) points.push({x:0,y:0});
                
                const idata = tx.getImageData(0,0,sw,sh).data;
                let r=0, g=0, b=0, n=0;
                points.forEach(p => {
                    const idx = (p.y*sw+p.x)*4;
                    if(idx<0||idx>=idata.length) return;
                    if(idata[idx+3]<50) return; // Ignore transparent
                    r+=idata[idx]; g+=idata[idx+1]; b+=idata[idx+2]; n++;
                });
                
                if(n===0) return '#ffffff';
                return "#"+((1<<24)+(Math.round(r/n)<<16)+(Math.round(g/n)<<8)+Math.round(b/n)).toString(16).slice(1);
            } catch(e){return '#ffffff';}
        }

        // Use Solid Patch for OCR to ensure full coverage
        function generateSolidPatch(x,y,w,h) {
             const c=document.createElement('canvas'); c.width=w; c.height=h; const xd=c.getContext('2d');
             xd.fillStyle = getDominantBorderColor(x,y,w,h);
             xd.fillRect(0,0,w,h);
             return c.toDataURL();
        }

        function generateInpaintPatch(x, y, w, h, srcImg) {
            const tCanvas = document.createElement('canvas'); tCanvas.width=w; tCanvas.height=h; const tCtx = tCanvas.getContext('2d');
            const bgHex = getDominantBorderColor(x,y,w,h); tCtx.fillStyle=bgHex; tCtx.fillRect(0,0,w,h);
            const bc=document.createElement('canvas'); bc.width=w; bc.height=h; const bx=bc.getContext('2d'); const bs=Math.max(1,Math.min(w,h)*0.15);
            const safeX=Math.max(0,x), safeY=Math.max(0,y);
            bx.drawImage(srcImg,safeX,safeY,w,bs,0,0,w,bs); bx.drawImage(srcImg,safeX,safeY+h-bs,w,bs,0,h-bs,w,bs); bx.drawImage(srcImg,safeX,safeY,bs,h,0,0,bs,h); bx.drawImage(srcImg,safeX+w-bs,safeY,bs,h,w-bs,0,bs,h);
            const sm=Math.max(1,Math.min(w,h)/8), sc=document.createElement('canvas'); sc.width=sm; sc.height=sm; sc.getContext('2d').drawImage(bc,0,0,w,h,0,0,sm,sm);
            tCtx.globalAlpha=0.9; tCtx.drawImage(sc,0,0,sm,sm,0,0,w,h); tCtx.globalAlpha=1; return tCanvas.toDataURL();
        }

        // Strict Refit: Ensure text fits INSIDE box width/height
        function refitTextBlock(b) {
            let minS=10, maxS=200, best=20; 
            // Use strict limits (box size - padding)
            const maxW = b.width - b.padding*2, maxH = b.height - b.padding*2;
            ctx.font=`${b.fontWeight} 200px ${b.fontFamily}`;
            if (b.letterSpacing) ctx.letterSpacing = b.letterSpacing + "px";
            
            while(minS<=maxS){
                const mid=Math.floor((minS+maxS)/2); ctx.font=`${b.fontWeight} ${mid}px ${b.fontFamily}`;
                const lines=b.text.split('\n'); let w=0; lines.forEach(l=>w=Math.max(w,ctx.measureText(l).width));
                const h=lines.length*mid*b.lineHeight;
                // Strict check: No 1.5x buffer, must fit inside
                if(w<=maxW && h<=maxH) { best=mid; minS=mid+1; } else maxS=mid-1;
            }
            b.fontSize=best;
            // Clear spacing for other ops
            ctx.letterSpacing = "0px";
        }

        async function runOCR() {
            if(!img.src||!selectionBox.active)return; 
            const box={...selectionBox}; 
            if(box.w<5||box.h<5) { showToast("範圍太小",true); return; }
            selectionBox.active=false; draw(); loadingOverlay.classList.remove('hidden'); loadingStatus.textContent="OCR 辨識中...";
            
            try {
                // Ensure integer coords
                const w=Math.floor(box.w), h=Math.floor(box.h), x=Math.floor(box.x), y=Math.floor(box.y);
                
                // Crop for OCR
                const tc=document.createElement('canvas'); tc.width=w; tc.height=h; const tx=tc.getContext('2d'); 
                tx.drawImage(img,x,y,w,h,0,0,w,h);
                const idata=tx.getImageData(0,0,w,h); const d=idata.data;

                // Color Detection: Simple Brightness Contrast
                const bgHex = getDominantBorderColor(x,y,w,h);
                const bgR=parseInt(bgHex.slice(1,3),16), bgG=parseInt(bgHex.slice(3,5),16), bgB=parseInt(bgHex.slice(5,7),16);
                const bgLum = 0.299*bgR + 0.587*bgG + 0.114*bgB;
                
                let tr=0,tg=0,tb=0,cnt=0;
                // Sample center area
                const cx=Math.floor(w/2), cy=Math.floor(h/2), rad=Math.min(w,h)/3; 
                for(let sy=cy-rad; sy<cy+rad; sy+=2){
                    for(let sx=cx-rad; sx<cx+rad; sx+=2){
                        const idx=(Math.floor(sy)*w+Math.floor(sx))*4;
                        if(idx<0||idx>=d.length) continue;
                        const r=d[idx], g=d[idx+1], b=d[idx+2];
                        const lum = 0.299*r+0.587*g+0.114*b;
                        if((bgLum>128 && lum<bgLum-60) || (bgLum<=128 && lum>bgLum+60)){
                            tr+=r; tg+=g; tb+=b; cnt++;
                        }
                    }
                }
                const txtColor = cnt>0 ? "#"+((1<<24)+(Math.round(tr/cnt)<<16)+(Math.round(tg/cnt)<<8)+Math.round(tb/cnt)).toString(16).slice(1) : (bgLum>128?'#000000':'#ffffff');
                
                // 修正：只有在背景非常深 (暗色模式) 且文字判斷不佳時才考慮反相
                if(bgLum <= 80) {
                     for(let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; } 
                     tx.putImageData(idata,0,0); 
                }

                // 修正：加入 'eng' 支援混合辨識 (chi_tra+eng)，解決 % 符號錯誤問題
                const worker=await Tesseract.createWorker('chi_tra+eng');
                const res=await worker.recognize(tc.toDataURL()); await worker.terminate();
                let txt=res.data.text.replace(/\s+/g,'').replace(/\n/g,'');
                
                if(txt.length>0) {
                    // 1. Create Solid Patch (Fixes black/transparent background issue)
                    const pSrc = generateSolidPatch(x, y, w, h);
                    const pIb = new PatchBlock(x, y, w, h, bgHex, pSrc); // Use PatchBlock for non-selectable bg
                    await new Promise(r=>pIb.load(r));
                    patches.push(pIb);

                    // 2. Create Text Block
                    const nb=new TextBlock(x,y,txt,20,w,h); 
                    nb.hasBackground=false; 
                    nb.color=txtColor; 
                    nb.bgColor=bgHex; 
                    
                    refitTextBlock(nb);
                    texts.push(nb);
                    
                    selectedIndex = texts.length-1; 
                    selectedType = 'text';
                    
                    recordHistory(); draw(); 
                    showToast("OCR 成功"); // Safe now
                    updateInputs();
                    ['textProperties','imageProperties','blockProperties'].forEach(k=>document.getElementById(k).classList.add('hidden'));
                    document.getElementById('textProperties').classList.remove('hidden');
                } else showToast("未辨識出文字",true);
            } catch(e){console.error(e);alert("OCR 錯誤: "+(e.message||"未知"));} finally{loadingOverlay.classList.add('hidden');}
        }

        // 5. 截圖去背 (Magic Crop) - 改名並修正邏輯
        function magicCrop() {
             if (!selectionBox.active) return;
             const box = {...selectionBox}; selectionBox.active = false; draw();
             loadingOverlay.classList.remove('hidden'); loadingStatus.textContent = "截圖去背中...";

             setTimeout(() => {
                 const w = Math.floor(box.w), h = Math.floor(box.h);
                 const tCanvas = document.createElement('canvas'); tCanvas.width = w; tCanvas.height = h;
                 const tCtx = tCanvas.getContext('2d');
                 tCtx.drawImage(img, box.x, box.y, box.w, box.h, 0, 0, w, h);
                 
                 const idata = tCtx.getImageData(0,0,w,h);
                 const d = idata.data;
                 
                 // 去背邏輯: 從四個角落採樣背景色，進行擴散消除
                 const bgR = d[0], bgG = d[1], bgB = d[2];
                 const stack = []; const visited = new Uint8Array(w*h);
                 for(let x=0; x<w; x++) { stack.push([x,0]); stack.push([x,h-1]); }
                 for(let y=0; y<h; y++) { stack.push([0,y]); stack.push([w-1,y]); }
                 
                 while(stack.length > 0) {
                     const [x,y] = stack.pop();
                     if(x<0||x>=w||y<0||y>=h) continue;
                     const p = y*w+x;
                     if(visited[p]) continue; visited[p]=1;
                     const idx = p*4;
                     const dist = (d[idx]-bgR)**2 + (d[idx+1]-bgG)**2 + (d[idx+2]-bgB)**2;
                     if(dist < 3000) { 
                         d[idx+3] = 0; // 設為透明
                         stack.push([x+1,y]); stack.push([x-1,y]); stack.push([x,y+1]); stack.push([x,y-1]);
                     }
                 }
                 tCtx.putImageData(idata, 0, 0);

                 // 1. 產生純色補丁修補原圖 (填補空洞，不選取，無框線)
                 const patchSrc = generateInpaintPatch(box.x, box.y, w, h, img);
                 const bgHex = getDominantBorderColor(box.x, box.y, w, h);
                 // Using PatchBlock with src for textured background that is NOT selectable
                 const patch = new PatchBlock(box.x, box.y, w, h, bgHex, patchSrc);
                 
                 // 2. 產生物件圖層 (去背後的物件，可選取)
                 const cutoutIb = new ImageBlock(box.x, box.y, tCanvas.toDataURL(), box.w, box.h);
                 
                 patch.load(() => {
                    patches.push(patch); 
                    cutoutIb.load(()=>{
                        images.push(cutoutIb); 
                        loadingOverlay.classList.add('hidden');
                        recordHistory(); 
                        selectItem('image', images.length - 1); 
                        draw();
                        showToast("已分離物件並填補背景");
                    });
                 });

             }, 50);
        }

        function eraseSelection() {
            if (!selectionBox.active) return;
            const box={...selectionBox}; selectionBox.active = false; draw();
            const bg = getDominantBorderColor(box.x, box.y, box.w, box.h); 
            blocks.push(new ColorBlock(Math.floor(box.x), Math.floor(box.y), Math.floor(box.w), Math.floor(box.h), bg));
            recordHistory(); selectItem('block', blocks.length - 1); draw();
        }

        function removeWatermarkSelection() {
            if(!img.src || !selectionBox.active) return;
            const box = {...selectionBox}; selectionBox.active=false; draw(); 
            const patchSrc = generateInpaintPatch(box.x, box.y, box.w, box.h, img);
            const newIb = new PatchBlock(box.x, box.y, box.w, box.h, '#ffffff', patchSrc); // Use PatchBlock for watermark removal
            newIb.load(()=>{ patches.push(newIb); recordHistory(); draw(); });
        }

        function startPickRemoveBg() { 
            if(selectedIndex !== -1 && selectedType === 'image') { 
                setTool('magic_wand'); 
                showToast("請點擊圖片背景顏色進行去除"); 
            } else {
                showToast("請先點選一張圖片", true);
            }
        }
        
        function removeBgFromImage(clickX, clickY) {
            if(selectedIndex === -1 || selectedType !== 'image') return;
            const imgBlock = images[selectedIndex];
            const w = imgBlock.width * imgBlock.scale, h = imgBlock.height * imgBlock.scale;
            if(clickX < imgBlock.x || clickX > imgBlock.x + w || clickY < imgBlock.y || clickY > imgBlock.y + h) return;
            loadingOverlay.classList.remove('hidden');
            setTimeout(() => {
                const tC = document.createElement('canvas'); tC.width = imgBlock.width; tC.height = imgBlock.height;
                const tX = tC.getContext('2d'); tX.drawImage(imgBlock.imgElement, 0, 0);
                const localX = Math.floor((clickX - imgBlock.x) / imgBlock.scale), localY = Math.floor((clickY - imgBlock.y) / imgBlock.scale);
                const idata = tX.getImageData(0, 0, tC.width, tC.height); const data = idata.data;
                const idx0 = (localY * tC.width + localX) * 4;
                const sR = data[idx0], sG = data[idx0+1], sB = data[idx0+2], sA = data[idx0+3];
                if(sA === 0) { loadingOverlay.classList.add('hidden'); return; }

                const tolSq = (parseInt(document.getElementById('bgTolerance').value)||50)**2;
                const stack = [[localX, localY]]; const visited = new Uint8Array(tC.width * tC.height);
                while(stack.length > 0) {
                    const [x,y] = stack.pop(); const p = y*tC.width+x;
                    if(visited[p]) continue; visited[p]=1;
                    const idx = p*4;
                    const dist = (data[idx]-sR)**2 + (data[idx+1]-sG)**2 + (data[idx+2]-sB)**2;
                    if(dist <= tolSq) {
                        data[idx+3] = 0;
                        if(x>0) stack.push([x-1,y]); if(x<tC.width-1) stack.push([x+1,y]);
                        if(y>0) stack.push([x,y-1]); if(y<tC.height-1) stack.push([x,y+1]);
                    }
                }
                tX.putImageData(idata, 0, 0);
                imgBlock.src = tC.toDataURL();
                imgBlock.load(() => { loadingOverlay.classList.add('hidden'); recordHistory(); draw(); });
            }, 50);
        }

        function applyMaskRemoval() {
            if(maskStrokes.length===0) return;
            loadingOverlay.classList.remove('hidden'); loadingStatus.textContent = "AI 智慧填補中...";
            setTimeout(() => {
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                maskStrokes.forEach(s=>{ s.points.forEach(p=>{ minX=Math.min(minX,p.x-s.size); minY=Math.min(minY,p.y-s.size); maxX=Math.max(maxX,p.x+s.size); maxY=Math.max(maxY,p.y+s.size); }); });
                const padding = 20;
                minX = Math.max(0, Math.floor(minX - padding));
                minY = Math.max(0, Math.floor(minY - padding));
                maxX = Math.min(img.width, Math.ceil(maxX + padding));
                maxY = Math.min(img.height, Math.ceil(maxY + padding));
                const w=maxX-minX, h=maxY-minY;
                if(w>0 && h>0) {
                    const mC = document.createElement('canvas'); mC.width=w; mC.height=h; const mX = mC.getContext('2d');
                    mX.lineCap='round'; mX.strokeStyle='#fff'; 
                    maskStrokes.forEach(s=>{ mX.lineWidth=s.size; mX.beginPath(); if(s.points.length>0) mX.moveTo(s.points[0].x-minX, s.points[0].y-minY); for(let i=1;i<s.points.length;i++) mX.lineTo(s.points[i].x-minX, s.points[i].y-minY); mX.stroke(); });
                    const pSrc = generateInpaintPatch(minX, minY, w, h, img);
                    const newIb = new PatchBlock(minX, minY, w, h, '#ffffff', pSrc); // Use PatchBlock for mask removal result
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        const finalC = document.createElement('canvas'); finalC.width=w; finalC.height=h; const fX = finalC.getContext('2d');
                        fX.drawImage(tempImg, 0, 0); 
                        fX.globalCompositeOperation = 'destination-in';
                        fX.drawImage(mC, 0, 0); 
                        newIb.src = finalC.toDataURL(); // Update src with masked version
                        newIb.load(()=>{ 
                            patches.push(newIb); 
                            maskStrokes=[]; 
                            document.getElementById('applyMaskBtn').disabled=true; 
                            loadingOverlay.classList.add('hidden'); 
                            recordHistory(); 
                            draw();
                            // NEW: Auto exit
                            setTool('select');
                            showToast("去除完成，已返回游標模式");
                        }); 
                    }; 
                    tempImg.src=pSrc;
                } else { loadingOverlay.classList.add('hidden'); }
            }, 50);
        }

        // --- Interaction & Drawing ---
        function getCanvasPos(e) { const r=canvasContainer.getBoundingClientRect(); return {x:(e.clientX-r.left-view.x)/view.scale, y:(e.clientY-r.top-view.y)/view.scale}; }
        function draw() {
            if(!img.complete||img.width===0)return; canvas.width=img.width; canvas.height=img.height; canvas.style.transform=`translate(${view.x}px,${view.y}px) scale(${view.scale})`; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0);
            
            // Draw Patches (now supports texture images)
            patches.forEach(p=>{
                if(p.imgElement && p.imgElement.complete) {
                    ctx.drawImage(p.imgElement, p.x, p.y, p.w, p.h);
                } else {
                    ctx.fillStyle=p.color;ctx.fillRect(p.x,p.y,p.w,p.h);
                }
            });

            blocks.forEach((b,i)=>{ctx.fillStyle=b.color;ctx.fillRect(b.x,b.y,b.width,b.height); if(selectedType==='block'&&selectedIndex===i)drawSelection(b.x,b.y,b.width,b.height,Math.max(1,1/view.scale),true);});
            images.forEach((b,i)=>{if(b.imgElement){const w=b.width*b.scale,h=b.height*b.scale;ctx.drawImage(b.imgElement,b.x,b.y,w,h); if(selectedType==='image'&&selectedIndex===i)drawSelection(b.x,b.y,w,h,Math.max(1,1/view.scale),true);}});
            if(maskStrokes.length>0){ ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='rgba(255,0,0,0.5)'; maskStrokes.forEach(s=>{ ctx.lineWidth=s.size; ctx.beginPath(); if(s.points.length>0)ctx.moveTo(s.points[0].x,s.points[0].y); for(let i=1;i<s.points.length;i++)ctx.lineTo(s.points[i].x,s.points[i].y); ctx.stroke(); }); ctx.restore(); }
            
            texts.forEach((b,i)=>{ 
                ctx.font=`${b.fontWeight} ${b.fontSize}px ${b.fontFamily}`; 
                // Add letter spacing support
                if(b.letterSpacing) ctx.letterSpacing = b.letterSpacing + "px";
                else ctx.letterSpacing = "0px";

                ctx.textBaseline='top'; 
                const lh=b.fontSize*b.lineHeight, lines=b.text.split('\n'); 
                // Removed the auto-height resizing line to allow box movement & stability
                if(b.hasBackground){ctx.fillStyle=b.bgColor;ctx.fillRect(b.x,b.y,b.width,b.height);} 
                if(selectedType==='text'&&selectedIndex===i)drawSelection(b.x,b.y,b.width,b.height,Math.max(1,1/view.scale),true); 
                ctx.fillStyle=b.color; ctx.textAlign=b.textAlign; 
                lines.forEach((l,ix)=>{let dx=b.x+b.padding; if(b.textAlign==='center')dx+=(b.width-b.padding*2)/2; else if(b.textAlign==='right')dx+=(b.width-b.padding*2); ctx.fillText(l,dx,b.y+b.padding+ix*lh);}); 
            });
            // Reset global context state
            ctx.letterSpacing = "0px";
            
            if(selectionBox.active){ ctx.save(); ctx.strokeStyle='#ef4444'; ctx.lineWidth=2*Math.max(1,1/view.scale); ctx.setLineDash([6,6]); ctx.strokeRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h); ctx.restore(); }
        }
        function drawSelection(x,y,w,h,s,handle){ ctx.save(); ctx.strokeStyle='#2563eb'; ctx.lineWidth=2*s; ctx.strokeRect(x,y,w,h); if(handle){const hs=12*s; ctx.fillStyle='#10b981'; ctx.fillRect(x+w-hs/2,y+h-hs/2,hs,hs);} ctx.restore(); }

        canvasContainer.addEventListener('mousedown', e=>{ if(e.target===canvasContainer||e.target.closest('#placeholder')||currentTool==='hand'){isDraggingView=true; lastMouseX=e.clientX; lastMouseY=e.clientY; canvasContainer.style.cursor='grabbing';} });
        canvasContainer.addEventListener('wheel', e=>{ e.preventDefault(); adjustZoom(e.deltaY>0?-0.1:0.1); }, {passive:false});
        canvas.addEventListener('mousedown', e=>{
            if(currentTool==='hand')return; e.stopPropagation(); e.preventDefault(); const pos=getCanvasPos(e);
            if(currentTool==='mask'){ isDrawingMask=true; maskStrokes.push({points:[{x:pos.x,y:pos.y}], size:parseInt(document.getElementById('brushSize').value)||20}); draw(); return; }
            if(currentTool==='picker'){ pickColor(pos.x,pos.y); setTool('select'); return; }
            if(currentTool==='magic_wand'){ removeBgFromImage(pos.x,pos.y); setTool('select'); return; }
            if(currentTool==='rect'){ isCreatingRect=true; newRectStart={x:Math.floor(pos.x),y:Math.floor(pos.y)}; blocks.push(new ColorBlock(newRectStart.x,newRectStart.y,0,0,'#e2e8f0')); selectItem('block',blocks.length-1); return; }
            
            const s=Math.max(1,1/view.scale), hs=20*s, tol=10*s;
            // Check Hit - Reverse order
            let found = false;
            const chk=(l,t)=>{ 
                if(found) return true;
                for(let i=l.length-1;i>=0;i--){ 
                    const b=l[i], w=(b.width||20)*(b.scale||1), h=(b.height||20)*(b.scale||1); 
                    // Resize Handle (Check corner)
                    if(selectedIndex===i && selectedType===t && pos.x>=b.x+w-hs && pos.x<=b.x+w+hs && pos.y>=b.y+h-hs && pos.y<=b.y+h+hs){ isResizingItem=true; resizeStart={x:pos.x,y:pos.y,w:w,h:h,fontSize:b.fontSize||0}; found=true; return true; } 
                    // Move Body
                    if(pos.x>=b.x-tol && pos.x<=b.x+w+tol && pos.y>=b.y-tol && pos.y<=b.y+h+tol){ 
                        isDraggingItem=true; dragOffset={x:pos.x-b.x,y:pos.y-b.y}; selectItem(t,i); found=true; return true; 
                    } 
                } return false; 
            };
            
            chk(texts,'text'); chk(images,'image'); chk(blocks,'block');
            
            if(!found){ 
                if(selectionBox.active && pos.x>=selectionBox.x && pos.x<=selectionBox.x+selectionBox.w && pos.y>=selectionBox.y && pos.y<=selectionBox.y+selectionBox.h){ isDraggingSelection=true; dragOffset={x:pos.x-selectionBox.x, y:pos.y-selectionBox.y}; }
                else { deselectAll(); isSelecting=true; selectionStartX=pos.x; selectionStartY=pos.y; selectionBox={x:Math.floor(pos.x),y:Math.floor(pos.y),w:0,h:0,active:true}; }
            } 
            draw();
        });
        
        // Updated mousemove for text box resizing
        window.addEventListener('mousemove', e=>{
            if(isDraggingView){ view.x+=e.clientX-lastMouseX; view.y+=e.clientY-lastMouseY; lastMouseX=e.clientX; lastMouseY=e.clientY; draw(); return; }
            const pos=getCanvasPos(e);
            if(isDrawingMask&&currentTool==='mask'){ maskStrokes[maskStrokes.length-1].points.push({x:pos.x,y:pos.y}); draw(); return; }
            if(isCreatingRect){ const b=blocks[blocks.length-1]; b.width=Math.abs(pos.x-newRectStart.x); b.height=Math.abs(pos.y-newRectStart.y); b.x=Math.min(pos.x,newRectStart.x); b.y=Math.min(pos.y,newRectStart.y); draw(); }
            else if(isResizingItem){ 
                if(selectedType==='block'){ blocks[selectedIndex].width=Math.max(10,pos.x-blocks[selectedIndex].x); blocks[selectedIndex].height=Math.max(10,pos.y-blocks[selectedIndex].y); } 
                else if(selectedType==='image'){ images[selectedIndex].scale=Math.max(10,pos.x-images[selectedIndex].x)/images[selectedIndex].width; document.getElementById('imgScale').value=images[selectedIndex].scale; } 
                else if(selectedType==='text'){ 
                    const b=texts[selectedIndex];
                    // Update dimensions based on mouse pos
                    b.width = Math.max(20, pos.x - b.x);
                    b.height = Math.max(20, pos.y - b.y);
                    // Recalculate font size to fit new box
                    refitTextBlock(b);
                    document.getElementById('fontSize').value=Math.floor(b.fontSize); 
                } 
                draw(); 
            }
            else if(isDraggingItem){ const l=selectedType==='text'?texts:(selectedType==='image'?images:blocks); l[selectedIndex].x=pos.x-dragOffset.x; l[selectedIndex].y=pos.y-dragOffset.y; draw(); }
            else if(isDraggingSelection){ selectionBox.x=pos.x-dragOffset.x; selectionBox.y=pos.y-dragOffset.y; draw(); }
            else if(isSelecting){ selectionBox.w=Math.abs(pos.x-selectionStartX); selectionBox.h=Math.abs(pos.y-selectionStartY); selectionBox.x=Math.min(pos.x,selectionStartX); selectionBox.y=Math.min(pos.y,selectionStartY); draw(); }
        });
        window.addEventListener('mouseup', ()=>{
            if(isDrawingMask){ isDrawingMask=false; document.getElementById('applyMaskBtn').disabled=maskStrokes.length===0; }
            if(isCreatingRect||isDraggingItem||isResizingItem){ if(isCreatingRect){isCreatingRect=false;setTool('select');} recordHistory(); isDraggingItem=false; isResizingItem=false; }
            if(isDraggingView){ isDraggingView=false; canvasContainer.style.cursor='grab'; }
            if(isSelecting){ if(selectionBox.w<0){selectionBox.x+=selectionBox.w;selectionBox.w=Math.abs(selectionBox.w);} if(selectionBox.h<0){selectionBox.y+=selectionBox.h;selectionBox.h=Math.abs(selectionBox.h);} const h=selectionBox.active&&selectionBox.w>5&&selectionBox.h>5; document.getElementById('ocrBtn').disabled=!h; document.getElementById('magicBtn').disabled=!h; document.getElementById('watermarkBtn').disabled=!h; document.getElementById('eraseBtn').disabled=!h; }
            if(isDraggingSelection) isDraggingSelection=false; isSelecting=false; draw();
        });

        // Common Tools
        function clearMask() { maskStrokes = []; document.getElementById('applyMaskBtn').disabled = true; draw(); }
        function addText() { 
            ctx.font = "bold 30px 'Noto Sans TC'"; 
            const txt = "文字"; 
            const m = ctx.measureText(txt); 
            // Fix: Create box with enough padding
            const estHeight = 30 * 1.2 + 16; 
            const estWidth = m.width + 16; 
            texts.push(new TextBlock(canvas.width/2 - estWidth/2, canvas.height/2 - estHeight/2, txt, 30, estWidth, estHeight)); 
            selectItem('text', texts.length-1); 
            recordHistory(); 
            draw(); 
        }
        function addQRCode() { const u=prompt("URL"); if(u){ const d=document.createElement('div'); new QRCode(d,{text:u}); setTimeout(()=>{const i=d.querySelector('img'); if(i){const b=new ImageBlock(canvas.width/2-64,canvas.height/2-64,i.src,0,0); b.load(()=>{images.push(b);recordHistory();draw();});}},100);} }
        function deleteSelected(){ if(selectedIndex!==-1){ if(selectedType==='text')texts.splice(selectedIndex,1); else if(selectedType==='image')images.splice(selectedIndex,1); else blocks.splice(selectedIndex,1); deselectAll(); recordHistory(); draw(); } }
        function activateEyedropper() { setTool(currentTool==='picker'?'select':'picker'); }
        function pickColor(x,y) { const tc = document.createElement('canvas'); tc.width=1; tc.height=1; tc.getContext('2d').drawImage(img, x, y, 1, 1, 0, 0, 1, 1); const p = tc.getContext('2d').getImageData(0,0,1,1).data; const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1); if(selectedIndex!==-1) { if(selectedType==='text'){ texts[selectedIndex].bgColor=hex; texts[selectedIndex].hasBackground=true; } else if(selectedType==='block') blocks[selectedIndex].color=hex; updateInputs(); recordHistory(); } draw(); }
        function setTool(t) { 
            currentTool = t; 
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); 
            if(t==='select') document.getElementById('toolSelect').classList.add('active'); 
            if(t==='hand') document.getElementById('toolHand').classList.add('active'); 
            if(t==='rect') document.getElementById('toolRect').classList.add('active'); 
            // Removed incorrect ID reference
            
            if(t === 'mask') { 
                document.getElementById('maskOptions').classList.remove('hidden'); 
                document.getElementById('maskEnterPanel').classList.add('hidden'); 
                document.getElementById('exitMaskBtn').classList.remove('hidden'); 
            } else { 
                document.getElementById('maskOptions').classList.add('hidden'); 
                document.getElementById('maskEnterPanel').classList.remove('hidden'); 
                document.getElementById('exitMaskBtn').classList.add('hidden'); 
            } 
            
            canvas.classList.toggle('cursor-crosshair', t==='mask'); 
            canvas.classList.toggle('cursor-magic', t==='magic_wand'); 
            canvas.classList.toggle('cursor-dropper', t==='picker'); 
            canvasContainer.style.cursor = t==='hand'?'grab':(t==='rect'?'crosshair':'default'); 
        }
        function exitMaskMode() { setTool('select'); }
        function updateInputs() { if(selectedIndex===-1) return; if(selectedType==='text'){ const b=texts[selectedIndex]; document.getElementById('textInput').value=b.text; document.getElementById('fontSize').value=b.fontSize; document.getElementById('textColor').value=b.color; document.getElementById('bgColor').value=b.bgColor; document.getElementById('hasBackground').checked=b.hasBackground; document.getElementById('fontWeight').value=b.fontWeight; document.getElementById('letterSpacing').value=b.letterSpacing||0; document.getElementById('lineHeight').value=b.lineHeight; } else if(selectedType==='image') document.getElementById('imgScale').value=images[selectedIndex].scale; else document.getElementById('blockColor').value=blocks[selectedIndex].color; }
        function selectItem(t, i) { selectedType=t; selectedIndex=i; selectionBox.active=false; updateInputs(); ['textProperties','imageProperties','blockProperties'].forEach(k=>document.getElementById(k).classList.add('hidden')); if(t==='text')document.getElementById('textProperties').classList.remove('hidden'); if(t==='image')document.getElementById('imageProperties').classList.remove('hidden'); if(t==='block')document.getElementById('blockProperties').classList.remove('hidden'); document.getElementById('ocrBtn').disabled=true; document.getElementById('magicBtn').disabled=true; document.getElementById('watermarkBtn').disabled=true; document.getElementById('eraseBtn').disabled=true; }
        function deselectAll() { selectedType=null; selectedIndex=-1; ['textProperties','imageProperties','blockProperties'].forEach(k=>document.getElementById(k).classList.add('hidden')); }
        function adjustZoom(d) { view.scale = Math.max(0.1, Math.min(5, view.scale + d)); document.getElementById('zoomLevel').textContent = `${Math.round(view.scale*100)}%`; draw(); }
        function resetView() { if(img.width===0)return; const r=Math.min(canvasContainer.clientWidth/img.width, canvasContainer.clientHeight/img.height); view={scale:r<1?r:1, x:(canvasContainer.clientWidth-img.width*(r<1?r:1))/2, y:(canvasContainer.clientHeight-img.height*(r<1?r:1))/2}; document.getElementById('zoomLevel').textContent=`${Math.round(view.scale*100)}%`; draw(); }
        
        async function downloadPDF() { 
            if(slides.length===0)return; 
            saveSlideState(); loadingOverlay.classList.remove('hidden'); loadingStatus.textContent="生成PDF..."; 
            const doc = new jspdf.jsPDF({ orientation: 'landscape', unit: 'px', format: [slides[0].originalImage.width, slides[0].originalImage.height] }); 
            for(let i=0; i<slides.length; i++) { 
                if(i>0) doc.addPage([slides[i].originalImage.width, slides[i].originalImage.height]); 
                const s=slides[i], tC=document.createElement('canvas'); tC.width=s.originalImage.width; tC.height=s.originalImage.height; const tx=tC.getContext('2d'); 
                // Draw Slide
                tx.drawImage(s.originalImage,0,0); 
                (s.patches||[]).forEach(p=>{ if(p.imgElement && p.imgElement.complete) tx.drawImage(p.imgElement, p.x, p.y, p.w, p.h); else { tx.fillStyle=p.color; tx.fillRect(p.x,p.y,p.w,p.h); } }); 
                (s.blocks||[]).forEach(b=>{tx.fillStyle=b.color; tx.fillRect(b.x,b.y,b.width,b.height)}); 
                for(const imgD of (s.images||[])) { const ti=new Image(); ti.src=imgD.src; await new Promise(r=>ti.onload=r); tx.drawImage(ti,imgD.x,imgD.y,imgD.width*imgD.scale,imgD.height*imgD.scale); } 
                (s.texts||[]).forEach(b=>{tx.font=`${b.fontWeight} ${b.fontSize}px ${b.fontFamily}`; if(b.letterSpacing) tx.letterSpacing = b.letterSpacing + "px"; else tx.letterSpacing = "0px"; tx.textBaseline='top'; const lh=b.fontSize*b.lineHeight, ls=b.text.split('\n'); if(b.hasBackground){tx.fillStyle=b.bgColor;tx.fillRect(b.x,b.y,b.width,ls.length*lh+b.padding*2);} tx.fillStyle=b.color; ls.forEach((l,ix)=>tx.fillText(l,b.x+b.padding,b.y+b.padding+ix*lh));}); 
                doc.addImage(tC.toDataURL('image/jpeg',0.9),'JPEG',0,0,tC.width,tC.height); 
            } 
            doc.save(`edited_${Date.now()}.pdf`); loadingOverlay.classList.add('hidden'); 
        }

        async function downloadPPTX() {
            if(slides.length === 0) return;
            saveSlideState();
            loadingOverlay.classList.remove('hidden');
            loadingStatus.textContent = "生成 PPTX...";

            try {
                const pptx = new PptxGenJS();
                // 像素到英吋的轉換 (假設 96 DPI)
                const layoutW = slides[0].originalImage.width / 96;
                const layoutH = slides[0].originalImage.height / 96;
                pptx.defineLayout({ name: 'CUSTOM', width: layoutW, height: layoutH });
                pptx.layout = 'CUSTOM';

                for (let i = 0; i < slides.length; i++) {
                    const slide = pptx.addSlide();
                    
                    // Render the full visual state to a canvas
                    const s = slides[i];
                    const tC = document.createElement('canvas');
                    tC.width = s.originalImage.width;
                    tC.height = s.originalImage.height;
                    const tx = tC.getContext('2d');
                    
                    // 1. BG
                    tx.drawImage(s.originalImage, 0, 0);
                    
                    // 2. Patches
                    (s.patches||[]).forEach(p=>{
                        if(p.imgElement && p.imgElement.complete) {
                            tx.drawImage(p.imgElement, p.x, p.y, p.w, p.h);
                        } else {
                            tx.fillStyle=p.color; tx.fillRect(p.x,p.y,p.w,p.h);
                        }
                    });
                    
                    // 3. Blocks
                    (s.blocks||[]).forEach(b=>{tx.fillStyle=b.color;tx.fillRect(b.x,b.y,b.width,b.height)});
                    
                    // 4. Images
                    for(const im of (s.images||[])){
                        const io=new Image(); io.src=im.src; 
                        await new Promise(r=>io.onload=r); 
                        tx.drawImage(io,im.x,im.y,im.width*im.scale,im.height*im.scale);
                    }
                    
                    // 5. Texts
                    (s.texts||[]).forEach(b=>{
                        tx.font=`${b.fontWeight} ${b.fontSize}px ${b.fontFamily}`; 
                        if(b.letterSpacing) tx.letterSpacing = b.letterSpacing + "px"; else tx.letterSpacing = "0px";
                        tx.textBaseline='top'; 
                        const lh=b.fontSize*b.lineHeight, ls=b.text.split('\n'); 
                        if(b.hasBackground){tx.fillStyle=b.bgColor;tx.fillRect(b.x,b.y,b.width,b.height);} 
                        tx.fillStyle=b.color; 
                        ls.forEach((l,ix)=>tx.fillText(l,b.x+b.padding,b.y+b.padding+ix*lh));
                    });

                    // Add to PPT slide as a single high-quality image
                    const dataUrl = tC.toDataURL('image/png');
                    slide.addImage({ data: dataUrl, x: 0, y: 0, w: '100%', h: '100%' });
                }

                await pptx.writeFile({ fileName: `edited_slides_${Date.now()}.pptx` });
                showToast("PPTX 下載成功");
            } catch (e) {
                console.error(e);
                alert("PPTX 生成失敗: " + e.message);
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }

        function downloadImage() { if(!img.src)return; const l=view; view={scale:1,x:0,y:0}; draw(); const a=document.createElement('a'); a.download=`slide_${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click(); view=l; draw(); }
        
        // Listeners for props
        document.getElementById('textInput').oninput=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].text=document.getElementById('textInput').value; refitTextBlock(texts[selectedIndex]); draw();}};
        document.getElementById('fontSize').oninput=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].fontSize=parseInt(document.getElementById('fontSize').value); draw();}};
        document.getElementById('textColor').oninput=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].color=document.getElementById('textColor').value; draw();}};
        document.getElementById('bgColor').oninput=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].bgColor=document.getElementById('bgColor').value; draw();}};
        document.getElementById('hasBackground').onchange=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].hasBackground=document.getElementById('hasBackground').checked; draw();}};
        document.getElementById('fontWeight').onchange=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].fontWeight=document.getElementById('fontWeight').value; draw();}};
        document.getElementById('imgScale').oninput=()=>{if(selectedIndex!==-1&&selectedType==='image'){images[selectedIndex].scale=parseFloat(document.getElementById('imgScale').value); draw();}};
        document.getElementById('blockColor').oninput=()=>{if(selectedIndex!==-1&&selectedType==='block'){blocks[selectedIndex].color=document.getElementById('blockColor').value; draw();}};
        document.getElementById('brushSize').oninput=()=>{document.getElementById('brushSizeVal').textContent = document.getElementById('brushSize').value;};
        document.getElementById('bgTolerance').oninput=()=>{document.getElementById('bgToleranceVal').textContent = document.getElementById('bgTolerance').value;};
        document.getElementById('letterSpacing').oninput=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].letterSpacing=parseInt(document.getElementById('letterSpacing').value)||0; refitTextBlock(texts[selectedIndex]); draw();}};
        document.getElementById('lineHeight').oninput=()=>{if(selectedIndex!==-1&&selectedType==='text'){texts[selectedIndex].lineHeight=parseFloat(document.getElementById('lineHeight').value)||1.2; refitTextBlock(texts[selectedIndex]); draw();}};
    </script>
</body>
</html>
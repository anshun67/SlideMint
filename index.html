<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圖片文字修改專家 - v17.1 PDF簡報神器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF Processing Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // Set PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Noto+Serif+TC:wght@400;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; user-select: none; }
        
        canvas { 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); 
            transform-origin: 0 0; 
        }
        .pattern-grid {
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Custom Scrollbar */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .tool-btn.active { background-color: #2563eb; color: white; border-color: #2563eb; }
        
        .slide-thumb { border: 2px solid transparent; transition: all 0.2s; cursor: pointer; opacity: 0.7; }
        .slide-thumb:hover { opacity: 1; }
        .slide-thumb.active { border-color: #2563eb; opacity: 1; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2); }

        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 8px;
            padding: 12px 16px;
            position: fixed;
            z-index: 100;
            left: 50%;
            top: -60px; 
            transform: translateX(-50%);
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.3s, top 0.3s;
        }
        #toast.show { visibility: visible; opacity: 1; top: 20px; }
        #toast.error { background-color: #ef4444; }

        .cursor-crosshair { cursor: crosshair; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        
        .cursor-dropper {
            cursor: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTE0LjUgMmEzLjUgMy41IDAgMCAxIDUgNWwtMi41IDIuNUw4LjUgMjBsLTQuNSAxbDEtNC41TDE0LjUgMnoiLz48bGluZSB4MT0iMyIgeTE9IjIxIiB4Mj0iOSIgeTI9IjE1Ii8+PC9zdmc+") 0 24, crosshair !important;
        }
        .cursor-magic {
            cursor: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM5MzMzZWEiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMTQuNSAyYTMuNSAzLjUgMCAwIDEgNSA1bC0yLjUgMi41TDguNSAyMGwtNC41IDFsMS00LjVMMTQuNSAyeiIvPjxwYXRoIGQ9Ik0yMSAxMmwyIDItMiAyTTMgMTJsLTIgMiAyIDIiLz48L3N2Zz4=") 0 24, crosshair !important;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden flex flex-col items-center justify-center text-white">
        <div class="loader mb-4"></div>
        <h2 class="text-xl font-bold mb-2">處理中...</h2>
        <p id="loadingStatus" class="text-sm text-gray-200 font-mono">初始化...</p>
    </div>

    <div id="toast"><i class="fas fa-save mr-2 text-green-400"></i>已自動暫存編輯進度</div>

    <header class="bg-white border-b border-gray-200 p-3 flex justify-between items-center z-10 shadow-sm shrink-0">
        <div class="flex items-center gap-2">
            <div class="bg-blue-600 text-white p-2 rounded-lg">
                <i class="fas fa-file-pdf"></i>
            </div>
            <div class="flex flex-col">
                <h1 class="text-lg font-bold text-gray-800 leading-tight">
                    圖型文字修改專家 
                    <span class="text-xs bg-red-600 text-white px-2 py-0.5 rounded font-mono ml-1">v17.1 PDF</span>
                </h1>
                <span class="text-[10px] text-gray-500">NotebookLM 簡報專用編輯器</span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="undo()" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-lg transition" title="復原 (Ctrl+Z)">
                <i class="fas fa-undo"></i>
            </button>
            <div class="w-px h-8 bg-gray-300 mx-1"></div>
            
            <button onclick="document.getElementById('fileInput').click()" class="bg-indigo-50 hover:bg-indigo-100 text-indigo-700 px-4 py-2 rounded-lg transition flex items-center gap-2 font-medium border border-indigo-200">
                <i class="fas fa-file-upload"></i> <span class="hidden sm:inline">匯入 PDF/圖片</span>
            </button>
            
            <div class="flex rounded-lg shadow-sm" role="group">
                <button onclick="downloadImage()" class="bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 px-4 py-2 rounded-l-lg transition flex items-center gap-2 text-sm font-medium">
                    <i class="fas fa-image"></i> 單頁圖片
                </button>
                <button onclick="downloadPDF()" class="bg-blue-600 border border-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-r-lg transition flex items-center gap-2 text-sm font-medium">
                    <i class="fas fa-file-pdf"></i> 匯出 PDF
                </button>
            </div>
            
            <input type="file" id="fileInput" accept="image/*,application/pdf" class="hidden">
            <input type="file" id="overlayInput" accept="image/*" class="hidden">
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Slides Sidebar -->
        <div id="slidesPanel" class="w-48 bg-gray-50 border-r border-gray-200 flex flex-col shrink-0 hidden">
            <div class="p-3 border-b border-gray-200 bg-gray-100">
                <h3 class="text-xs font-bold text-gray-500 uppercase">投影片 (<span id="slideCount">0</span>)</h3>
            </div>
            <div id="slidesContainer" class="flex-1 overflow-y-auto p-3 space-y-3 custom-scroll">
                <!-- Slides will be injected here -->
            </div>
        </div>

        <!-- Tools Sidebar -->
        <aside class="w-72 bg-white border-r border-gray-200 flex flex-col p-3 gap-3 overflow-y-auto z-10 shadow-lg shrink-0 custom-scroll">
            <div class="bg-gray-50 p-2 rounded-lg border border-gray-200 grid grid-cols-6 gap-1">
                <button onclick="setTool('select')" id="toolSelect" class="tool-btn active p-2 rounded hover:bg-white hover:shadow transition col-span-1" title="選取">
                    <i class="fas fa-mouse-pointer"></i>
                </button>
                <button onclick="setTool('hand')" id="toolHand" class="tool-btn p-2 rounded hover:bg-white hover:shadow transition col-span-1" title="平移">
                    <i class="fas fa-hand-paper"></i>
                </button>
                <button onclick="setTool('rect')" id="toolRect" class="tool-btn p-2 rounded hover:bg-white hover:shadow transition col-span-1" title="色塊">
                    <i class="fas fa-vector-square"></i>
                </button>
                <button onclick="adjustZoom(-0.1)" class="p-2 rounded bg-white hover:bg-gray-100 shadow-sm transition col-span-1" title="縮小">
                    <i class="fas fa-minus"></i>
                </button>
                <button onclick="adjustZoom(0.1)" class="p-2 rounded bg-white hover:bg-gray-100 shadow-sm transition col-span-1" title="放大">
                    <i class="fas fa-plus"></i>
                </button>
                <button onclick="resetView()" class="p-2 rounded bg-white hover:bg-gray-100 shadow-sm transition col-span-1" title="原圖大小置中">
                    <i class="fas fa-expand"></i>
                </button>
                <div class="col-span-6 text-center text-[10px] text-gray-400 mt-1" id="zoomLevel">100%</div>
            </div>

            <!-- Mask Brush Tool -->
            <div class="bg-rose-50 p-3 rounded-lg border border-rose-200 space-y-2">
                 <h3 class="text-xs font-bold text-rose-700 uppercase tracking-wider mb-1 flex justify-between">
                     <span><i class="fas fa-magic"></i> 塗抹去印</span>
                 </h3>
                 <button onclick="setTool('mask')" id="toolMask" class="w-full tool-btn bg-white border border-rose-200 hover:bg-rose-100 text-rose-900 py-1.5 rounded shadow-sm text-sm font-bold flex items-center justify-center gap-2">
                     <i class="fas fa-paint-brush"></i> 進入塗抹模式
                 </button>
                 
                 <div id="maskOptions" class="hidden text-xs text-rose-800 space-y-2 pt-2 border-t border-rose-200">
                     <div class="flex items-center justify-between">
                         <span>筆刷: <span id="brushSizeVal">20</span></span>
                         <input type="range" id="brushSize" min="5" max="100" value="20" class="w-16 h-2 bg-rose-200 rounded-lg appearance-none cursor-pointer">
                     </div>
                     <div class="flex gap-2 pt-1">
                        <button onclick="clearMask()" class="flex-1 bg-white hover:bg-gray-100 text-gray-600 py-1 rounded border border-gray-300">清除</button>
                        <button id="applyMaskBtn" onclick="applyMaskRemoval()" disabled class="flex-1 bg-rose-600 hover:bg-rose-700 text-white py-1 rounded shadow disabled:opacity-50 disabled:cursor-not-allowed">
                            <i class="fas fa-check"></i> 去除
                        </button>
                     </div>
                 </div>
            </div>

            <div id="controls" class="space-y-3 opacity-50 pointer-events-none transition-opacity duration-300 pb-8">
                <div class="space-y-1">
                    <label class="block text-xs font-bold text-gray-500 uppercase tracking-wider">編輯工具</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="magicBtn" onclick="magicCrop()" disabled class="col-span-1 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]">
                            <i class="fas fa-cut"></i> <span>智能去背</span>
                        </button>
                        <button id="watermarkBtn" onclick="removeWatermarkSelection()" disabled class="col-span-1 bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-600 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]">
                            <i class="fas fa-magic"></i> <span>選框去印</span>
                        </button>
                        <button id="eraseBtn" onclick="eraseSelection()" disabled class="col-span-1 bg-gray-500 hover:bg-gray-600 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px]">
                            <i class="fas fa-eraser"></i> <span>純色覆蓋</span>
                        </button>
                        <button id="ocrBtn" onclick="runOCR()" disabled class="col-span-1 bg-gray-500 text-white py-2 rounded-lg font-bold transition flex flex-col justify-center items-center gap-1 shadow-sm text-[10px] cursor-not-allowed">
                            <i class="fas fa-font"></i> <span>OCR 辨識</span>
                        </button>
                    </div>
                </div>
                
                <div class="flex flex-col gap-2 border-t pt-3">
                    <div class="flex gap-2">
                         <button onclick="addText()" class="flex-1 bg-white border border-gray-300 hover:border-indigo-500 hover:text-indigo-600 text-gray-600 py-1.5 rounded-lg font-bold transition flex justify-center items-center gap-2 text-xs">
                            <i class="fas fa-font"></i> 文字
                        </button>
                        <button onclick="addQRCode()" class="flex-1 bg-white border border-gray-300 hover:border-green-500 hover:text-green-600 text-gray-600 py-1.5 rounded-lg font-bold transition flex justify-center items-center gap-2 text-xs">
                            <i class="fas fa-qrcode"></i> QR
                        </button>
                    </div>
                    <button onclick="document.getElementById('overlayInput').click()" class="w-full bg-white border border-gray-300 hover:border-orange-500 hover:text-orange-600 text-gray-600 py-1.5 rounded-lg font-bold transition flex justify-center items-center gap-2 text-xs">
                        <i class="fas fa-image"></i> 插入圖片 (Logo/貼圖)
                    </button>
                </div>

                <div class="border-t pt-3">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xs font-bold text-gray-500 uppercase">屬性</h3>
                        <div class="flex gap-1">
                            <button onclick="deleteSelected()" class="text-red-500 hover:bg-red-50 px-2 py-1 rounded text-xs"><i class="fas fa-trash"></i></button>
                        </div>
                    </div>
                    
                    <div id="textProperties" class="space-y-2 hidden">
                        <textarea id="textInput" rows="2" class="w-full border border-gray-300 rounded p-1.5 text-xs" placeholder="文字內容..."></textarea>
                        
                        <div class="grid grid-cols-2 gap-2">
                            <div><label class="text-[10px] text-gray-500">大小</label><input type="number" id="fontSize" class="w-full border rounded p-1 text-xs"></div>
                            <div><label class="text-[10px] text-gray-500">顏色</label><div class="flex items-center gap-1 border rounded p-1 bg-white"><input type="color" id="textColor" class="w-4 h-4"><span id="textColorHex" class="text-[10px] text-gray-400"></span></div></div>
                        </div>
                        <div>
                            <label class="text-[10px] text-gray-500">背景</label>
                            <div class="flex items-center gap-1 border rounded p-1 bg-white">
                                <input type="checkbox" id="hasBackground" class="accent-blue-600 mr-1">
                                <input type="color" id="bgColor" class="w-4 h-4">
                                <button onclick="activateEyedropper()" id="eyedropperBtn" class="ml-auto text-xs p-1 hover:bg-gray-100 rounded text-gray-500"><i class="fas fa-eye-dropper"></i></button>
                            </div>
                        </div>
                        <div><label class="text-[10px] text-gray-500">字重</label><select id="fontWeight" class="w-full border rounded p-1 text-xs"><option value="normal">一般</option><option value="bold">粗體</option></select></div>
                    </div>
                    
                    <div id="imageProperties" class="space-y-2 hidden">
                         <button onclick="startPickRemoveBg()" id="pickRemoveBgBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white py-1.5 rounded text-xs mb-1">
                             <i class="fas fa-eye-dropper"></i> 吸色去背
                         </button>
                         <div>
                            <label class="text-[10px] text-gray-500">容許值: <span id="bgToleranceVal">50</span></label>
                            <input type="range" id="bgTolerance" min="1" max="150" value="50" class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                         <div>
                             <label class="text-[10px] text-gray-500">縮放</label>
                             <input type="range" id="imgScale" min="0.1" max="5" step="0.1" class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                         </div>
                    </div>

                    <div id="blockProperties" class="space-y-2 hidden">
                        <div>
                            <label class="text-[10px] text-gray-500">顏色</label>
                             <div class="flex items-center gap-1 border border-gray-300 rounded p-1 bg-white">
                                <input type="color" id="blockColor" class="w-4 h-4 border border-gray-200">
                                <button onclick="activateEyedropper()" id="eyedropperBlockBtn" class="ml-auto text-xs p-1 hover:bg-gray-100 rounded text-gray-500"><i class="fas fa-eye-dropper"></i></button>
                            </div>
                        </div>
                   </div>
                </div>
            </div>
        </aside>

        <main class="flex-1 bg-gray-200 pattern-grid relative overflow-hidden" id="canvasContainer">
            <div id="placeholder" class="flex flex-col h-full justify-center items-center text-center text-gray-400 pointer-events-none select-none p-8">
                <i class="fas fa-file-pdf text-6xl mb-4 text-gray-300"></i>
                <h2 class="text-xl font-bold text-gray-500">載入簡報開始編輯</h2>
                <p class="text-sm mt-2 text-gray-400 max-w-md">支援 NotebookLM 生成的 PDF 簡報或一般圖片。載入後可逐頁去浮水印、修補背景或加入註解。</p>
            </div>
            <!-- Canvas -->
            <canvas id="canvas" class="hidden shadow-2xl bg-white absolute top-0 left-0 origin-top-left"></canvas>
            <div id="qrCodeTemp" class="hidden"></div>
        </main>
    </div>

    <script>
        // --- Core Elements ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const overlayInput = document.getElementById('overlayInput');
        const controls = document.getElementById('controls');
        const placeholder = document.getElementById('placeholder');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingStatus = document.getElementById('loadingStatus');
        const canvasContainer = document.getElementById('canvasContainer');
        const toast = document.getElementById('toast');
        const slidesPanel = document.getElementById('slidesPanel');
        const slidesContainer = document.getElementById('slidesContainer');
        const slideCountDisplay = document.getElementById('slideCount');

        // --- Tools & Inputs ---
        const ocrBtn = document.getElementById('ocrBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const magicBtn = document.getElementById('magicBtn'); 
        const watermarkBtn = document.getElementById('watermarkBtn');
        const eyedropperBtn = document.getElementById('eyedropperBtn');
        const eyedropperBlockBtn = document.getElementById('eyedropperBlockBtn');
        const pickRemoveBgBtn = document.getElementById('pickRemoveBgBtn');
        const zoomLevelDisplay = document.getElementById('zoomLevel');
        
        const textProperties = document.getElementById('textProperties');
        const imageProperties = document.getElementById('imageProperties');
        const blockProperties = document.getElementById('blockProperties');
        const maskOptions = document.getElementById('maskOptions');
        const applyMaskBtn = document.getElementById('applyMaskBtn');
        const textPropHint = document.getElementById('textPropHint');

        const textInput = document.getElementById('textInput');
        const fontSizeInput = document.getElementById('fontSize');
        const textColorInput = document.getElementById('textColor');
        const bgColorInput = document.getElementById('bgColor');
        const hasBackgroundInput = document.getElementById('hasBackground');
        const fontWeightInput = document.getElementById('fontWeight');
        const imgScaleInput = document.getElementById('imgScale');
        const bgToleranceInput = document.getElementById('bgTolerance');
        const bgToleranceVal = document.getElementById('bgToleranceVal');
        const blockColorInput = document.getElementById('blockColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeVal = document.getElementById('brushSizeVal');

        const alignBtns = { left: document.getElementById('alignLeft'), center: document.getElementById('alignCenter'), right: document.getElementById('alignRight') };

        // --- Global State ---
        let currentSlideIndex = 0;
        let slides = []; // Array of slide objects: { originalImage: Image, texts: [], patches: [], blocks: [], images: [], maskStrokes: [] }
        
        // Current Slide Working State (Mirrors slides[currentSlideIndex])
        let img = new Image(); // The background image of current slide
        let texts = []; 
        let patches = []; 
        let blocks = []; 
        let images = []; // Additional overlay images (stickers, etc)
        let maskStrokes = []; // For red brush
        
        let selectedIndex = -1; 
        let selectedType = null; 

        let view = { scale: 1, x: 0, y: 0 };
        let isDraggingView = false, lastMouseX = 0, lastMouseY = 0;
        
        let currentTool = 'select'; 
        let isSelecting = false, selectionBox = { x: 0, y: 0, w: 0, h: 0, active: false };
        let selectionStartX = 0, selectionStartY = 0; 
        let isCreatingRect = false, newRectStart = { x: 0, y: 0 };
        let isDraggingItem = false, isResizingItem = false, dragOffset = { x: 0, y: 0 }, resizeStart = { w:0, h:0, x:0, y:0, fontSize:0 }; 
        let isDraggingSelection = false; 
        let isDrawingMask = false;
        let isRemovingBg = false;

        let historyStack = []; // Simple history for current slide only
        let historyPointer = -1;
        const MAX_HISTORY = 20;

        // --- Classes ---
        class TextBlock {
            constructor(x, y, text, fontSize = 30, w = 0, h = 0, autoFit = false) {
                this.x = Math.floor(x || 0); this.y = Math.floor(y || 0); 
                this.text = text; this.fontSize = fontSize;
                this.fontFamily = "'Noto Sans TC', sans-serif"; this.fontWeight = 'bold';
                this.color = '#000000'; this.hasBackground = false; this.bgColor = '#ffffff';
                this.padding = 4; this.textAlign = 'left'; this.lineHeight = 1.2;
                this.letterSpacing = 0; 
                this.width = Math.floor(w || 0); this.height = Math.floor(h || 0); 
                this.autoFit = autoFit;
            }
        }
        class PatchBlock { constructor(x, y, w, h, color) { this.x=x; this.y=y; this.w=w; this.h=h; this.color=color; } }
        class ColorBlock { constructor(x, y, w, h, color) { this.x=x; this.y=y; this.width=w; this.height=h; this.color=color; } }
        class ImageBlock {
            constructor(x, y, imgSrc, w, h) { this.x=x; this.y=y; this.src=imgSrc; this.imgElement=null; this.scale=1; this.width=w; this.height=h; }
            load(cb) {
                this.imgElement = new Image();
                this.imgElement.onload = () => {
                    if(!this.width) this.width = this.imgElement.width;
                    if(!this.height) this.height = this.imgElement.height;
                    if(cb) cb();
                }
                this.imgElement.onerror = () => { if(cb) cb(); }; 
                this.imgElement.src = this.src;
            }
        }

        // --- Initialization ---
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); }
                else if (e.key === 'y') { e.preventDefault(); redo(); }
            }
            if (e.key === 'Escape') {
                if(isRemovingBg) { isRemovingBg = false; setTool('select'); pickRemoveBgBtn.classList.remove('bg-red-600'); pickRemoveBgBtn.classList.add('bg-purple-600'); pickRemoveBgBtn.innerHTML = '<i class="fas fa-eye-dropper"></i> 吸色去背'; }
                if(currentTool === 'mask') setTool('select');
            }
        });

        function showToast(msg, isError = false) {
            toast.innerHTML = isError ? `<i class="fas fa-exclamation-triangle mr-2"></i> ${msg}` : `<i class="fas fa-check-circle mr-2 text-green-400"></i> ${msg}`;
            toast.className = isError ? "show error" : "show";
            setTimeout(() => { toast.className = ""; }, 3000);
        }

        // --- Undo/Redo (Per Slide) ---
        function recordHistory() {
            if (historyPointer < historyStack.length - 1) historyStack = historyStack.slice(0, historyPointer + 1);
            const state = JSON.stringify({ texts, patches, blocks, images: images.map(i => ({ x: i.x, y: i.y, src: i.src, scale: i.scale, width: i.width, height: i.height })) });
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) historyStack.shift(); else historyPointer++;
            saveSlideState(); // Sync global to slide object
        }
        function undo() { if (historyPointer > 0) { historyPointer--; loadHistoryState(historyStack[historyPointer]); } }
        function redo() { if (historyPointer < historyStack.length - 1) { historyPointer++; loadHistoryState(historyStack[historyPointer]); } }
        function loadHistoryState(jsonStr) {
            const state = JSON.parse(jsonStr);
            texts = state.texts.map(t => Object.assign(new TextBlock(), t));
            patches = state.patches.map(p => Object.assign(new PatchBlock(), p));
            blocks = state.blocks.map(b => Object.assign(new ColorBlock(), b));
            const newImages = [];
            if(state.images.length === 0) { images = []; draw(); }
            else {
                let loaded = 0;
                state.images.forEach(idata => {
                    const ib = new ImageBlock(idata.x, idata.y, idata.src, idata.width, idata.height); ib.scale = idata.scale;
                    ib.load(() => { loaded++; if(loaded===state.images.length) { images = newImages; draw(); } });
                    newImages.push(ib);
                });
            }
            deselectAll(); draw(); saveSlideState();
        }

        // --- Multi-Slide Logic ---
        function saveSlideState() {
            if (!slides[currentSlideIndex]) return;
            // Save deep copy of metadata
            slides[currentSlideIndex].texts = JSON.parse(JSON.stringify(texts));
            slides[currentSlideIndex].patches = JSON.parse(JSON.stringify(patches));
            slides[currentSlideIndex].blocks = JSON.parse(JSON.stringify(blocks));
            slides[currentSlideIndex].images = images.map(i => ({ x: i.x, y: i.y, src: i.src, scale: i.scale, width: i.width, height: i.height }));
            slides[currentSlideIndex].maskStrokes = JSON.parse(JSON.stringify(maskStrokes));
        }

        function loadSlide(index) {
            if (index < 0 || index >= slides.length) return;
            saveSlideState(); // Save old slide
            currentSlideIndex = index;
            
            // UI Update
            document.querySelectorAll('.slide-thumb').forEach((el, i) => {
                if (i === index) el.classList.add('active'); else el.classList.remove('active');
                el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            });

            const slide = slides[index];
            img = slide.originalImage; // Set background
            
            // Restore Objects
            texts = (slide.texts || []).map(t => Object.assign(new TextBlock(), t));
            patches = (slide.patches || []).map(p => Object.assign(new PatchBlock(), p));
            blocks = (slide.blocks || []).map(b => Object.assign(new ColorBlock(), b));
            maskStrokes = (slide.maskStrokes || []);
            
            // Async Image Load
            const savedImgs = slide.images || [];
            images = [];
            if (savedImgs.length > 0) {
                savedImgs.forEach(idata => {
                    const ib = new ImageBlock(idata.x, idata.y, idata.src, idata.width, idata.height); ib.scale = idata.scale;
                    ib.load(() => { images.push(ib); draw(); });
                });
            } else {
                images = [];
            }

            // Reset History for this session (simpler than complex history tree)
            historyStack = []; historyPointer = -1;
            recordHistory(); // Initial state
            
            resetView();
            draw();
        }

        function renderSlideThumbnails() {
            slidesContainer.innerHTML = '';
            slides.forEach((slide, index) => {
                const div = document.createElement('div');
                div.className = `slide-thumb relative rounded overflow-hidden shadow-sm bg-white aspect-[4/3] flex items-center justify-center ${index === currentSlideIndex ? 'active' : ''}`;
                div.onclick = () => loadSlide(index);
                
                const thumbImg = document.createElement('img');
                thumbImg.src = slide.thumbnail;
                thumbImg.className = "max-w-full max-h-full object-contain";
                
                const num = document.createElement('div');
                num.className = "absolute bottom-1 right-1 bg-black bg-opacity-50 text-white text-[10px] px-1.5 rounded";
                num.textContent = index + 1;

                div.appendChild(thumbImg);
                div.appendChild(num);
                slidesContainer.appendChild(div);
            });
            slideCountDisplay.textContent = slides.length;
            slidesPanel.classList.remove('hidden');
        }

        // --- File Handling (PDF & Image) ---
        fileInput.addEventListener('change', async function(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                loadingOverlay.classList.remove('hidden');
                loadingStatus.textContent = "讀取檔案...";
                
                if (file.type === 'application/pdf') {
                    await handlePDF(file);
                } else {
                    await handleImage(file);
                }
                
                loadingOverlay.classList.add('hidden');
                controls.classList.remove('opacity-50', 'pointer-events-none');
                placeholder.classList.add('hidden');
                canvas.classList.remove('hidden');
            }
        });

        // Overlay Image Input Handler
        overlayInput.addEventListener('change', function(e) {
            if (e.target.files && e.target.files[0] && img.src) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const i = new Image();
                    i.onload = () => {
                        // Center the image
                        const scale = Math.min(1, (canvas.width * 0.5) / i.width);
                        const w = i.width;
                        const h = i.height;
                        const x = (canvas.width - w * scale) / 2;
                        const y = (canvas.height - h * scale) / 2;
                        
                        const b = new ImageBlock(x, y, i.src, w, h);
                        b.scale = scale;
                        b.load(() => {
                            images.push(b);
                            recordHistory();
                            draw();
                            selectItem('image', images.length - 1);
                        });
                    };
                    i.src = event.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            }
            // Reset input so same file can be selected again
            e.target.value = '';
        });

        async function handleImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const i = new Image();
                    i.onload = () => {
                        slides = [{
                            originalImage: i,
                            thumbnail: i.src,
                            texts: [], patches: [], blocks: [], images: [], maskStrokes: []
                        }];
                        renderSlideThumbnails();
                        loadSlide(0);
                        resolve();
                    };
                    i.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        async function handlePDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                slides = [];
                const totalPages = pdf.numPages;

                for (let i = 1; i <= totalPages; i++) {
                    loadingStatus.textContent = `處理頁面 ${i} / ${totalPages}...`;
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 2.0 }); // High res for editing
                    
                    const c = document.createElement('canvas');
                    c.width = viewport.width;
                    c.height = viewport.height;
                    const cCtx = c.getContext('2d');
                    
                    await page.render({ canvasContext: cCtx, viewport: viewport }).promise;
                    
                    const imgSrc = c.toDataURL('image/jpeg', 0.85);
                    const imgObj = new Image();
                    imgObj.src = imgSrc;
                    
                    // Wait for image object to be ready
                    await new Promise(r => imgObj.onload = r);

                    slides.push({
                        originalImage: imgObj,
                        thumbnail: imgSrc, // Use full res as thumb for simplicity, browser scales it
                        texts: [], patches: [], blocks: [], images: [], maskStrokes: []
                    });
                }
                
                renderSlideThumbnails();
                loadSlide(0);
            } catch (err) {
                console.error(err);
                alert("PDF 解析失敗。請確認檔案未加密。");
            }
        }

        // --- Export Functions ---
        async function downloadPDF() {
            if (slides.length === 0) return;
            loadingOverlay.classList.remove('hidden');
            loadingStatus.textContent = "正在生成 PDF...";
            
            // Temporary save current slide
            saveSlideState();
            
            // Initialize jsPDF
            const doc = new jspdf.jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [slides[0].originalImage.width, slides[0].originalImage.height] // Use first slide dims as base
            });

            for (let i = 0; i < slides.length; i++) {
                loadingStatus.textContent = `匯出頁面 ${i+1} / ${slides.length}...`;
                if (i > 0) doc.addPage([slides[i].originalImage.width, slides[i].originalImage.height]);
                
                // Render slide to temp canvas
                const tCanvas = document.createElement('canvas');
                tCanvas.width = slides[i].originalImage.width;
                tCanvas.height = slides[i].originalImage.height;
                const tCtx = tCanvas.getContext('2d');
                
                // Draw background
                tCtx.drawImage(slides[i].originalImage, 0, 0);
                
                // Draw Objects (Reproduce logic from draw())
                const s = slides[i];
                (s.patches||[]).forEach(p => { tCtx.fillStyle=p.color; tCtx.fillRect(p.x, p.y, p.w, p.h); });
                (s.blocks||[]).forEach(b => { tCtx.fillStyle=b.color; tCtx.fillRect(b.x, b.y, b.width, b.height); });
                
                // Images need special handling (async load if not cached, but here we assume loaded)
                // We use the stored base64 src
                for(const idata of (s.images||[])) {
                    const tmpImg = new Image();
                    tmpImg.src = idata.src;
                    await new Promise(r => tmpImg.onload = r);
                    tCtx.drawImage(tmpImg, idata.x, idata.y, idata.width*idata.scale, idata.height*idata.scale);
                }

                // Text
                (s.texts||[]).forEach(b => {
                    tCtx.font = `${b.fontWeight} ${b.fontSize}px ${b.fontFamily}`;
                    tCtx.textBaseline = 'top';
                    const lh = b.fontSize*b.lineHeight;
                    const lines = b.text.split('\n'); // Simplified wrap for export speed
                    
                    if(b.hasBackground) { tCtx.fillStyle=b.bgColor; tCtx.fillRect(b.x, b.y, b.width, b.height); }
                    
                    tCtx.fillStyle=b.color; tCtx.textAlign=b.textAlign;
                    lines.forEach((l, idx) => {
                        let dx = b.x+b.padding, dy = b.y+b.padding + idx*lh;
                        if(b.textAlign==='center') dx += (b.width-b.padding*2)/2;
                        else if(b.textAlign==='right') dx += (b.width-b.padding*2);
                        tCtx.fillText(l, dx, dy);
                    });
                });

                const imgData = tCanvas.toDataURL('image/jpeg', 0.9);
                doc.addImage(imgData, 'JPEG', 0, 0, tCanvas.width, tCanvas.height);
            }
            
            doc.save(`edited_presentation_${Date.now()}.pdf`);
            loadingOverlay.classList.add('hidden');
            showToast("PDF 下載成功");
        }

        function downloadImage() {
            if(!img.src) return;
            // Temporarily hide selection box
            const sv = {...view}, ss = selectionBox.active, si = selectedIndex; 
            selectionBox.active = false; selectedIndex = -1; selectedType = null; 
            
            // Draw current state clean
            canvas.style.transform = `translate(0px, 0px) scale(1)`; // Reset view for capture
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            
            // Manually replicate draw() logic here without view transform OR simply call draw() then revert
            // Simpler: Reset view variable, call draw, export, restore view variable
            view = { scale: 1, x: 0, y: 0 };
            draw();
            
            const link = document.createElement('a');
            link.download = `slide_${currentSlideIndex+1}_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            // Restore
            view = sv; selectionBox.active = ss; selectedIndex = si;
            draw();
        }

        // --- Drawing Logic (Standard) ---
        function draw() {
            if (!img.complete || img.naturalWidth === 0) return; 
            
            canvas.width = img.width; 
            canvas.height = img.height; // Ensure canvas size matches slide
            
            canvas.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            const uiScale = Math.max(1, 1/view.scale);

            // Objects
            patches.forEach(p => { ctx.fillStyle=p.color; ctx.fillRect(p.x, p.y, p.w, p.h); });
            blocks.forEach((b, i) => {
                ctx.fillStyle=b.color; ctx.fillRect(b.x, b.y, b.width, b.height);
                if(selectedType==='block' && selectedIndex===i) drawSelection(b.x, b.y, b.width, b.height, uiScale, true);
            });
            images.forEach((b, i) => {
                if(!b.imgElement) return;
                const w=b.width*b.scale, h=b.height*b.scale;
                ctx.drawImage(b.imgElement, b.x, b.y, w, h);
                if(selectedType==='image' && selectedIndex===i) drawSelection(b.x, b.y, w, h, uiScale, true);
            });

            // Red Mask
            if(maskStrokes.length > 0) {
                ctx.save();
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                maskStrokes.forEach(stroke => {
                    if(stroke.points.length < 2) return;
                    ctx.lineWidth = stroke.size;
                    ctx.beginPath();
                    ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    for(let i=1; i<stroke.points.length; i++) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                    ctx.stroke();
                });
                ctx.restore();
            }

            // Text
            texts.forEach((b, i) => {
                ctx.font = `${b.fontWeight} ${b.fontSize}px ${b.fontFamily}`;
                ctx.textBaseline = 'top';
                const lh = b.fontSize*b.lineHeight;
                let lines = b.text.split('\n'); // Wrap logic omitted for brevity in draw loop, assuming pre-calc or basic split
                
                // Simple auto-fit calc if needed (usually done on input)
                if(!b.autoFit) { b.height = lines.length*lh + b.padding*2; }
                
                if(b.hasBackground) { ctx.fillStyle=b.bgColor; ctx.fillRect(b.x, b.y, b.width, b.height); }
                if(selectedType==='text' && selectedIndex===i) drawSelection(b.x, b.y, b.width, b.height, uiScale, true);
                
                ctx.fillStyle=b.color; ctx.textAlign=b.textAlign;
                lines.forEach((l, idx) => {
                    let dx = b.x+b.padding, dy = b.y+b.padding + idx*lh;
                    if(b.textAlign==='center') dx += (b.width-b.padding*2)/2;
                    else if(b.textAlign==='right') dx += (b.width-b.padding*2);
                    ctx.fillText(l, dx, dy);
                });
            });

            if(selectionBox.active) {
                ctx.save();
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2*uiScale;
                ctx.setLineDash([6*uiScale, 6*uiScale]);
                ctx.strokeRect(selectionBox.x, selectionBox.y, selectionBox.w, selectionBox.h);
                ctx.restore();
            }
        }

        function drawSelection(x, y, w, h, scale, handle) {
            ctx.save();
            ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2*scale;
            ctx.strokeRect(x, y, w, h);
            if(handle) {
                const hs = 12*scale;
                ctx.fillStyle = '#10b981';
                ctx.fillRect(x + w - hs/2, y + h - hs/2, hs, hs);
            }
            ctx.restore();
        }

        // --- Standard Tool Interactions (Identical logic to v16) ---
        // (For brevity, standard mouse/touch event listeners mapped to existing tool logic are kept)
        
        function getCanvasPos(e) {
            const rect = canvasContainer.getBoundingClientRect();
            return { x: (e.clientX - rect.left - view.x) / view.scale, y: (e.clientY - rect.top - view.y) / view.scale };
        }

        canvasContainer.addEventListener('mousedown', e => {
            if(e.target===canvasContainer || e.target.closest('#placeholder') || currentTool==='hand') {
                isDraggingView = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
                canvasContainer.style.cursor='grabbing';
            }
        });
        
        canvasContainer.addEventListener('wheel', e => { e.preventDefault(); adjustZoom(e.deltaY>0?-0.1:0.1); }, { passive: false });

        canvas.addEventListener('mousedown', e => {
            if(currentTool==='hand') return;
            e.stopPropagation(); e.preventDefault(); 
            const pos = getCanvasPos(e);
            
            if(currentTool==='mask') {
                isDrawingMask = true;
                const bs = parseInt(brushSizeInput.value) || 20;
                maskStrokes.push({ points: [{x: pos.x, y: pos.y}], size: bs });
                draw(); return;
            }
            if(currentTool==='picker') { pickColor(pos.x, pos.y); setTool('select'); return; }
            if(currentTool==='rect') {
                isCreatingRect=true; newRectStart={x:Math.floor(pos.x), y:Math.floor(pos.y)};
                blocks.push(new ColorBlock(Math.floor(pos.x), Math.floor(pos.y), 0, 0, '#e2e8f0'));
                selectItem('block', blocks.length-1); return;
            }
            
            const scale = Math.max(1, 1/view.scale);
            const hs = 20*scale, hitTol = 10*scale; 
            let hit = false; 

            if(selectedIndex!==-1) {
                let b = selectedType==='text'?texts[selectedIndex]:(selectedType==='image'?images[selectedIndex]:blocks[selectedIndex]);
                let w = b.width * (b.scale||1), h = b.height * (b.scale||1);
                if(pos.x >= b.x+w-hs && pos.x <= b.x+w+hs && pos.y >= b.y+h-hs && pos.y <= b.y+h+hs) {
                    isResizingItem = true; resizeStart = { x:pos.x, y:pos.y, w:w, h:h, fontSize: b.fontSize||0 }; return;
                }
            }

            for(let i=texts.length-1; i>=0; i--) if(hitTest(texts[i], pos, hitTol)) { isDraggingItem=true; dragOffset={x:pos.x-texts[i].x, y:pos.y-texts[i].y}; selectItem('text', i); hit=true; break; }
            if(!hit) for(let i=images.length-1; i>=0; i--) if(hitTest(images[i], pos, hitTol)) { isDraggingItem=true; dragOffset={x:pos.x-images[i].x, y:pos.y-images[i].y}; selectItem('image', i); hit=true; break; }
            if(!hit) for(let i=blocks.length-1; i>=0; i--) if(hitTest(blocks[i], pos, hitTol)) { isDraggingItem=true; dragOffset={x:pos.x-blocks[i].x, y:pos.y-blocks[i].y}; selectItem('block', i); hit=true; break; }
            
            if(!hit) {
                if(selectionBox.active && pos.x >= selectionBox.x && pos.x <= selectionBox.x + selectionBox.w && pos.y >= selectionBox.y && pos.y <= selectionBox.y + selectionBox.h) {
                    isDraggingSelection = true; dragOffset = { x: pos.x - selectionBox.x, y: pos.y - selectionBox.y };
                } else {
                    deselectAll(); isSelecting=true; selectionStartX=pos.x; selectionStartY=pos.y; 
                    selectionBox={x:Math.floor(pos.x), y:Math.floor(pos.y), w:0, h:0, active:true};
                }
            }
            draw();
        });

        window.addEventListener('mousemove', e => {
            if(isDraggingView) { view.x += e.clientX - lastMouseX; view.y += e.clientY - lastMouseY; lastMouseX = e.clientX; lastMouseY = e.clientY; draw(); return; }
            const pos = getCanvasPos(e);
            if(isDrawingMask && currentTool === 'mask') { maskStrokes[maskStrokes.length - 1].points.push({x: pos.x, y: pos.y}); draw(); return; }
            
            if(isCreatingRect) {
                const b = blocks[blocks.length-1];
                b.width = Math.abs(pos.x - newRectStart.x); b.height = Math.abs(pos.y - newRectStart.y);
                b.x = Math.min(pos.x, newRectStart.x); b.y = Math.min(pos.y, newRectStart.y);
                draw();
            } else if(isResizingItem) {
                // Resize logic (simplified)
                if(selectedType==='block') { blocks[selectedIndex].width = Math.max(10, pos.x - blocks[selectedIndex].x); blocks[selectedIndex].height = Math.max(10, pos.y - blocks[selectedIndex].y); }
                else if(selectedType==='image') { images[selectedIndex].scale = Math.max(10, pos.x - images[selectedIndex].x) / images[selectedIndex].width; imgScaleInput.value=images[selectedIndex].scale; }
                else if(selectedType==='text') {
                    const b = texts[selectedIndex];
                    const dy = pos.y - resizeStart.y;
                    b.fontSize = Math.max(10, resizeStart.fontSize + dy/2);
                    fontSizeInput.value = Math.floor(b.fontSize);
                }
                draw();
            } else if(isDraggingItem) {
                let list = selectedType==='text'?texts : selectedType==='image'?images : blocks;
                list[selectedIndex].x = pos.x - dragOffset.x; list[selectedIndex].y = pos.y - dragOffset.y; draw();
            } else if (isDraggingSelection) {
                selectionBox.x = pos.x - dragOffset.x; selectionBox.y = pos.y - dragOffset.y; draw();
            } else if(isSelecting) {
                selectionBox.w = Math.abs(pos.x - selectionStartX); selectionBox.h = Math.abs(pos.y - selectionStartY);
                selectionBox.x = Math.min(pos.x, selectionStartX); selectionBox.y = Math.min(pos.y, selectionStartY); draw(); 
            }
        });

        window.addEventListener('mouseup', () => {
            if(isDrawingMask) { isDrawingMask = false; applyMaskBtn.disabled = maskStrokes.length === 0; }
            if(isCreatingRect) { isCreatingRect=false; setTool('select'); recordHistory(); }
            if(isDraggingView) { isDraggingView=false; canvasContainer.style.cursor='grab'; }
            if(isSelecting) {
                if(selectionBox.w < 0) { selectionBox.x += selectionBox.w; selectionBox.w = Math.abs(selectionBox.w); }
                if(selectionBox.h < 0) { selectionBox.y += selectionBox.h; selectionBox.h = Math.abs(selectionBox.h); }
                updateSelectionBtns();
            }
            if(isDraggingSelection) isDraggingSelection = false;
            if(isDraggingItem||isResizingItem) { recordHistory(); }
            isDraggingItem=false; isResizingItem=false; isSelecting=false; draw();
        });

        // --- Helper Logic ---
        function hitTest(b, pos, tol) {
            const w = (b.width || 20) * (b.scale||1), h = (b.height || 20) * (b.scale||1);
            return pos.x>=b.x-tol && pos.x<=b.x+w+tol && pos.y>=b.y-tol && pos.y<=b.y+h+tol;
        }
        function setTool(t) {
            currentTool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if(t==='select') document.getElementById('toolSelect').classList.add('active');
            if(t==='hand') document.getElementById('toolHand').classList.add('active');
            if(t==='rect') document.getElementById('toolRect').classList.add('active');
            if(t==='mask') document.getElementById('toolMask').classList.add('active');
            maskOptions.classList.add('hidden');
            if(t==='mask') { maskOptions.classList.remove('hidden'); canvas.classList.add('cursor-crosshair'); }
            else { canvas.classList.remove('cursor-crosshair'); }
            canvasContainer.style.cursor = t==='hand'?'grab':(t==='rect'?'crosshair':'default');
        }
        function adjustZoom(d) { view.scale = Math.max(0.1, Math.min(5, view.scale + d)); zoomLevelDisplay.textContent = `${Math.round(view.scale*100)}%`; draw(); }
        function resetView() {
            const container = document.getElementById('canvasContainer');
            const ratio = Math.min(container.clientWidth / img.width, container.clientHeight / img.height);
            view = { scale: ratio < 1 ? ratio : 1, x: 0, y: 0 };
            view.x = (container.clientWidth - img.width * view.scale) / 2;
            view.y = (container.clientHeight - img.height * view.scale) / 2;
            zoomLevelDisplay.textContent = `${Math.round(view.scale*100)}%`;
            draw();
        }
        function updateSelectionBtns() {
            const has = selectionBox.active && selectionBox.w>5 && selectionBox.h>5;
            ocrBtn.disabled = !has; magicBtn.disabled = !has; watermarkBtn.disabled = !has; eraseBtn.disabled = !has;
            ocrBtn.classList.toggle('cursor-not-allowed', !has);
            ocrBtn.classList.toggle('bg-gray-500', !has);
            ocrBtn.classList.toggle('bg-indigo-600', has);
            eraseBtn.classList.toggle('cursor-not-allowed', !has);
            eraseBtn.classList.toggle('bg-gray-500', !has);
            eraseBtn.classList.toggle('bg-gray-600', has);
        }
        function selectItem(t, i) { 
            selectedType=t; selectedIndex=i; selectionBox.active=false; updateSelectionBtns(); updateInputs();
            textProperties.classList.add('hidden'); imageProperties.classList.add('hidden'); blockProperties.classList.add('hidden');
            if(t==='text') textProperties.classList.remove('hidden');
            if(t==='image') imageProperties.classList.remove('hidden');
            if(t==='block') blockProperties.classList.remove('hidden');
        }
        function deselectAll() { selectedType=null; selectedIndex=-1; textProperties.classList.add('hidden'); imageProperties.classList.add('hidden'); blockProperties.classList.add('hidden'); updateSelectionBtns(); }
        function updateInputs() {
            if(selectedIndex===-1) return;
            if(selectedType==='text'){
                const b=texts[selectedIndex]; textInput.value=b.text; fontSizeInput.value=b.fontSize; textColorInput.value=b.color;
                bgColorInput.value=b.bgColor; hasBackgroundInput.checked=b.hasBackground; fontWeightInput.value=b.fontWeight;
            } else if(selectedType==='image') imgScaleInput.value=images[selectedIndex].scale;
            else blockColorInput.value=blocks[selectedIndex].color;
        }
        
        // --- Feature Logic (Copied from v16 with simplification for brevity) ---
        function clearMask() { maskStrokes = []; applyMaskBtn.disabled = true; draw(); }
        function addText() { texts.push(new TextBlock(canvas.width/2-50, canvas.height/2-15, "文字", 30)); selectItem('text', texts.length-1); recordHistory(); draw(); }
        function addQRCode() { const u=prompt("URL"); if(u){ const d=document.createElement('div'); new QRCode(d,{text:u}); setTimeout(()=>{ const i=d.querySelector('img'); if(i){ const b=new ImageBlock(canvas.width/2-64,canvas.height/2-64,i.src,0,0); b.load(()=>{ images.push(b);recordHistory();draw(); }); } },100); } }
        function deleteSelected(){ if(selectedIndex!==-1){ if(selectedType==='text')texts.splice(selectedIndex,1); else if(selectedType==='image')images.splice(selectedIndex,1); else blocks.splice(selectedIndex,1); deselectAll(); recordHistory(); draw(); } }
        function activateEyedropper() { setTool(currentTool==='picker'?'select':'picker'); }
        function pickColor(x,y) { 
            const p = ctx.getImageData(x, y, 1, 1).data;
            const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
            if(selectedIndex!==-1) {
                if(selectedType==='text'){ texts[selectedIndex].bgColor=hex; texts[selectedIndex].hasBackground=true; }
                else if(selectedType==='block') blocks[selectedIndex].color=hex;
                updateInputs(); recordHistory();
            }
            draw();
        }

        // --- Advanced Features ---
        // 1. Solid Erase (Patch)
        function eraseSelection() {
            if (!selectionBox.active) return;
            const box={...selectionBox}; selectionBox.active = false; draw();
            const bg = getDominantBorderColor(box.x, box.y, box.w, box.h); 
            patches.push(new PatchBlock(box.x, box.y, box.w, box.h, bg));
            recordHistory(); draw();
        }

        function getDominantBorderColor(x, y, w, h) {
            try {
                const sx=Math.max(0,Math.floor(x)), sy=Math.max(0,Math.floor(y));
                const sw=Math.min(canvas.width-sx,Math.floor(w)), sh=Math.min(canvas.height-sy,Math.floor(h));
                if(sw<=0||sh<=0)return '#ffffff';
                const points=[];
                for(let i=0;i<sw;i+=5){points.push({x:sx+i,y:Math.max(0,sy-2)}); points.push({x:sx+i,y:Math.min(canvas.height-1,sy+sh+2)});}
                for(let j=0;j<sh;j+=5){points.push({x:Math.max(0,sx-2),y:sy+j}); points.push({x:Math.min(canvas.width-1,sx+sw+2),y:sy+j});}
                const counts={}; let max=0, dom='#ffffff';
                points.forEach(p=>{
                    const d=ctx.getImageData(p.x,p.y,1,1).data;
                    const r=Math.round(d[0]/10)*10, g=Math.round(d[1]/10)*10, b=Math.round(d[2]/10)*10;
                    const k=`${r},${g},${b}`;
                    counts[k]=(counts[k]||0)+1;
                    if(counts[k]>max){ max=counts[k]; dom="#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1); }
                });
                return dom;
            } catch { return '#ffffff'; }
        }

        // 2. Rectangular Watermark Removal (Smart Inpaint)
        function removeWatermarkSelection() {
            if(!img.src || !selectionBox.active) return;
            const box = {...selectionBox}; selectionBox.active=false;
            draw(); // Redraw clean canvas (base image)
            
            const w = Math.floor(box.w), h = Math.floor(box.h);
            const tCanvas = document.createElement('canvas'); 
            const tCtx = tCanvas.getContext('2d');
            tCanvas.width = w; tCanvas.height = h;
            
            // Random Patch Tiling Logic (High Quality)
            const patchSize = Math.max(8, Math.min(w, h) / 8);
            const patchesList = [];
            // Collect patches from borders of selection
            for(let x=0; x<w; x+=patchSize) {
                 patchesList.push({ sx: box.x + x, sy: box.y - patchSize }); 
                 patchesList.push({ sx: box.x + x, sy: box.y + h });
            }
            for(let y=0; y<h; y+=patchSize) {
                 patchesList.push({ sx: box.x - patchSize, sy: box.y + y });
                 patchesList.push({ sx: box.x + w, sy: box.y + y });
            }
            
            // Fallback
            if(patchesList.length === 0) patchesList.push({sx:0, sy:0});

            // Fill
            for(let x=0; x<w; x+=patchSize) {
                for(let y=0; y<h; y+=patchSize) {
                    let p = patchesList[Math.floor(Math.random()*patchesList.length)];
                    // Ensure source is within bounds
                    let safeSx = Math.max(0, Math.min(img.width - patchSize, p.sx));
                    let safeSy = Math.max(0, Math.min(img.height - patchSize, p.sy));
                    tCtx.drawImage(img, safeSx, safeSy, patchSize, patchSize, x, y, patchSize, patchSize);
                }
            }
            
            // Blur for blend
            const blurCanvas = document.createElement('canvas');
            blurCanvas.width = Math.max(1, w/4); blurCanvas.height = Math.max(1, h/4);
            const bCtx = blurCanvas.getContext('2d');
            bCtx.drawImage(tCanvas, 0, 0, blurCanvas.width, blurCanvas.height);
            tCtx.drawImage(blurCanvas, 0, 0, w, h);
            
            const newIb = new ImageBlock(box.x, box.y, tCanvas.toDataURL(), box.w, box.h);
            newIb.load(()=>{ 
                images.push(newIb); 
                recordHistory(); draw(); 
            });
        }

        // 3. Mask Removal (Brush Inpaint - High Quality)
        function applyMaskRemoval() {
            if(maskStrokes.length===0) return;
            loadingOverlay.classList.remove('hidden'); loadingStatus.textContent = "AI 智慧填補中...";
            
            setTimeout(() => {
                let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                maskStrokes.forEach(s=>{ s.points.forEach(p=>{ minX=Math.min(minX,p.x-s.size); minY=Math.min(minY,p.y-s.size); maxX=Math.max(maxX,p.x+s.size); maxY=Math.max(maxY,p.y+s.size); }); });
                
                // Expand bounds slightly to get context
                const padding = 20;
                minX = Math.max(0, Math.floor(minX - padding));
                minY = Math.max(0, Math.floor(minY - padding));
                maxX = Math.min(img.width, Math.ceil(maxX + padding));
                maxY = Math.min(img.height, Math.ceil(maxY + padding));
                
                const w=maxX-minX, h=maxY-minY;
                
                if(w>0 && h>0) {
                    // Create Mask
                    const mC = document.createElement('canvas'); mC.width=w; mC.height=h; const mX = mC.getContext('2d');
                    mX.lineCap='round'; mX.strokeStyle='#fff'; mX.shadowBlur=10; mX.shadowColor='white';
                    maskStrokes.forEach(s=>{ 
                        mX.lineWidth=s.size; mX.beginPath(); 
                        if(s.points.length>0) mX.moveTo(s.points[0].x-minX, s.points[0].y-minY);
                        for(let i=1;i<s.points.length;i++) mX.lineTo(s.points[i].x-minX, s.points[i].y-minY);
                        mX.stroke();
                    });

                    // Create Fill Pattern (Tiling from context)
                    const fC = document.createElement('canvas'); fC.width=w; fC.height=h; const fX = fC.getContext('2d');
                    const patchSize = Math.max(10, Math.min(w,h)/8);
                    
                    // Collect patches from the "Clean" area of this bounding box (border pixels)
                    // We simply take patches from the outer edge of the bounding box
                    const samples = [];
                    for(let i=0; i<w; i+=patchSize) { samples.push({x: minX+i, y: minY}); samples.push({x: minX+i, y: maxY-patchSize}); }
                    for(let i=0; i<h; i+=patchSize) { samples.push({x: minX, y: minY+i}); samples.push({x: maxX-patchSize, y: minY+i}); }
                    if(samples.length===0) samples.push({x:0, y:0});

                    for(let x=0; x<w; x+=patchSize) {
                        for(let y=0; y<h; y+=patchSize) {
                            let s = samples[Math.floor(Math.random()*samples.length)];
                            // Clamp
                            let sx = Math.max(0, Math.min(img.width-patchSize, s.x));
                            let sy = Math.max(0, Math.min(img.height-patchSize, s.y));
                            fX.drawImage(img, sx, sy, patchSize, patchSize, x, y, patchSize, patchSize);
                        }
                    }
                    
                    // Blur the fill
                    const bC = document.createElement('canvas'); bC.width=w/4; bC.height=h/4; 
                    const bX = bC.getContext('2d'); bX.drawImage(fC,0,0,bC.width,bC.height);
                    fX.drawImage(bC,0,0,w,h); 

                    // Composite
                    const finalC = document.createElement('canvas'); finalC.width=w; finalC.height=h; const finalX = finalC.getContext('2d');
                    finalX.drawImage(fC, 0, 0); // Fill
                    finalX.globalCompositeOperation = 'destination-in';
                    finalX.drawImage(mC, 0, 0); // Clip to Mask

                    const newIb = new ImageBlock(minX, minY, finalC.toDataURL(), w, h);
                    newIb.load(()=>{ images.push(newIb); maskStrokes=[]; applyMaskBtn.disabled=true; loadingOverlay.classList.add('hidden'); recordHistory(); draw(); });
                } else { loadingOverlay.classList.add('hidden'); }
            }, 50);
        }

        async function runOCR() {
            if(!img.src || !selectionBox.active) return;
            
            // UI Setup
            const box = {...selectionBox}; 
            selectionBox.active=false; 
            draw();
            loadingOverlay.classList.remove('hidden');
            loadingStatus.textContent = "初始化 OCR 引擎...";

            try {
                // 1. Prepare Image
                const tCanvas = document.createElement('canvas'); 
                const tCtx = tCanvas.getContext('2d');
                const w = Math.floor(box.w);
                const h = Math.floor(box.h);
                tCanvas.width = w; tCanvas.height = h;
                
                // Draw selected area
                tCtx.drawImage(img, box.x, box.y, box.w, box.h, 0, 0, w, h);
                
                // Pre-process: Simple contrast/invert if needed for better OCR
                // (Existing logic kept but ensured it works)
                const idata = tCtx.getImageData(0,0,w,h);
                const d = idata.data; 
                let r=0,g=0,b=0,c=0;
                for(let i=0;i<d.length;i+=40){r+=d[i];g+=d[i+1];b+=d[i+2];c++;}
                // If dark background, invert
                if(c>0 && (r+g+b)/(c*3)<100){ // Threshold 100
                    for(let i=0;i<d.length;i+=4){
                        d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2];
                    } 
                    tCtx.putImageData(idata,0,0); 
                }

                // 2. Run Tesseract (v5)
                // Use 'chi_tra' (Traditional Chinese) which usually includes English
                // Remove specific OEM to use default (Auto)
                const worker = await Tesseract.createWorker('chi_tra', 1, {
                    logger: m => { 
                        if(m.status === 'recognizing text') {
                            loadingStatus.textContent = `辨識中... ${(m.progress * 100).toFixed(0)}%`; 
                        } else {
                            loadingStatus.textContent = `載入語言包...`;
                        }
                    }
                });
                
                const ret = await worker.recognize(tCanvas.toDataURL());
                await worker.terminate();

                let txt = ret.data.text.replace(/\s+/g,'').replace(/\n/g,'');
                
                if(txt.length > 0) {
                    // Success: Create Text Block
                    const bg = getDominantBorderColor(box.x, box.y, box.w, box.h); 
                    patches.push(new PatchBlock(box.x, box.y, box.w, box.h, bg));
                    
                    const safeW = Math.max(20, Math.floor(box.w));
                    const safeH = Math.max(20, Math.floor(box.h));
                    
                    const nb = new TextBlock(Math.floor(box.x), Math.floor(box.y), txt, 20, safeW, safeH, true);
                    refitTextBlock(nb);
                    texts.push(nb);
                    
                    selectItem('text', texts.length - 1);
                    setTool('select');
                    recordHistory(); 
                    saveToDB(true); 
                    draw();
                    showToast("OCR 辨識成功");
                } else {
                    showToast("未能辨識出文字", true);
                }
            } catch (e) { 
                console.error(e);
                alert("OCR 辨識發生錯誤: " + (e.message || "網路或模型載入失敗")); 
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }

        // Binding inputs
        textInput.addEventListener('input', ()=>{ if(selectedIndex!==-1 && selectedType==='text'){ texts[selectedIndex].text=textInput.value; draw(); }});
        fontSizeInput.addEventListener('input', ()=>{ if(selectedIndex!==-1 && selectedType==='text'){ texts[selectedIndex].fontSize=parseInt(fontSizeInput.value); draw(); }});
        textColorInput.addEventListener('input', ()=>{ if(selectedIndex!==-1 && selectedType==='text'){ texts[selectedIndex].color=textColorInput.value; draw(); }});
        bgColorInput.addEventListener('input', ()=>{ if(selectedIndex!==-1 && selectedType==='text'){ texts[selectedIndex].bgColor=bgColorInput.value; draw(); }});
        blockColorInput.addEventListener('input', ()=>{ if(selectedIndex!==-1 && selectedType==='block'){ blocks[selectedIndex].color=blockColorInput.value; draw(); }});
        
    </script>
</body>
</html>